<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Johan Larsson" />

<meta name="date" content="2023-09-12" />

<title>An introduction to qualpalr</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/* el is the div, holding the rgl object as el.rglinstance,
     which holds x as el.rglinstance.scene
   x is the JSON encoded rglwidget.
*/


HTMLWidgets.widget({

  name: 'rglWebGL',

  type: 'output',

  factory: function(el, width, height) {
    el.width = width;
    el.height = height;
    var rgl = new rglwidgetClass(),
        onchangeselection = function(e) {
          for (var i = 0; i < rgl.scene.crosstalk.sel_handle.length; i++)
            rgl.clearBrush(except = e.rglSubsceneId);
          rgl.selection(e, false);
        },
        onchangefilter = function(e) {
          rgl.selection(e, true);
        };
    
    return { 
      renderValue: function(x) {
        var i, pel, player, groups,
            inShiny = (typeof Shiny !== "undefined");
      
        x.crosstalk.group = groups = [].concat(x.crosstalk.group);
        x.crosstalk.id = [].concat(x.crosstalk.id);
        x.crosstalk.key = [].concat(x.crosstalk.key);
        x.crosstalk.sel_handle = new Array(groups.length);
        x.crosstalk.fil_handle = new Array(groups.length);
        x.crosstalk.selection = [];
        for (i = 0; i < groups.length; i++) {
          x.crosstalk.sel_handle[i] = new crosstalk.SelectionHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.sel_handle[i].on("change", onchangeselection);
          x.crosstalk.fil_handle[i] = new crosstalk.FilterHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.fil_handle[i].on("change", onchangefilter);
        }
        if (inShiny) {
          // Shiny calls this multiple times, so we need extra cleanup
          // between
          rgl.sphere = undefined;
        }
        rgl.initialize(el, x);
        rgl.initGL();
  
  /* We might have been called after (some of) the players were rendered.
     We need to make sure we respond to their initial values. */

        if (typeof x.players !== "undefined") {
          var players = [].concat(x.players);
          for (i = 0; i < players.length; i++) {
            pel = document.getElementById(players[i]);
            if (pel) {
              player = pel.rglPlayer;
              if (player && (!player.initialized || inShiny)) {
                rgl.Player(pel, player);
                player.initialized = true;
              }
            }
          }
        }
        rgl.drag = 0;
        rgl.drawScene();
      },

      resize: function(width, height) {
        el.width = width;
        el.height = height;
        el.rglinstance.resize(el);
        el.rglinstance.drawScene();
      }
    };
  }
});
</script>
<style type="text/css">.rglPlayer {
width: auto;
height: auto;
}
.rglPlayer .rgl-button {
width: auto;
display: inline-block;
font-size: 75%;
}
.rglPlayer .rgl-slider {
display: inline-block;
width: 30%;
}
.rglPlayer .rgl-label {
display: inline;
padding-left: 6px;
padding-right: 6px;
}
</style>
<script>//// To generate the help pages for this library, use

// jsdoc --template /usr/local/lib/node_modules/foodoc/template *.src.js -R README.md -c JSDoc.json

// To test, set environment variable RGL_DEBUGGING=true
// before building.

/* globals rglwidgetClass: true */

/**
 * The class of an rgl widget
 * @class
*/
rglwidgetClass = function() {
    this.canvas = null;
    this.userMatrix = new CanvasMatrix4();
    this.types = [];
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    this.vp = null;
    this.prmvMatrix = null;
    this.origs = null;
    this.gl = null;
    this.scene = null;
    this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
    this.drawing = false;
};

    rglwidgetClass.f_is_lit = 1;
    rglwidgetClass.f_is_smooth = 2;
    rglwidgetClass.f_has_texture = 4;
    rglwidgetClass.f_depth_sort = 8;
    rglwidgetClass.f_fixed_quads = 16;
    rglwidgetClass.f_is_transparent = 32;
    rglwidgetClass.f_is_lines = 64;
    rglwidgetClass.f_sprites_3d = 128;
    rglwidgetClass.f_is_subscene = 256;
    rglwidgetClass.f_is_clipplanes = 512;
    rglwidgetClass.f_fixed_size = 1024;
    rglwidgetClass.f_is_points = 2048;
    rglwidgetClass.f_is_twosided = 4096;
    rglwidgetClass.f_fat_lines = 8192;
    rglwidgetClass.f_is_brush = 16384;
    rglwidgetClass.f_has_fog = 32768;
    rglwidgetClass.f_rotating = 65536;
    
    rglwidgetClass.prototype.fogNone = 0;
    rglwidgetClass.prototype.fogLinear = 1;
    rglwidgetClass.prototype.fogExp = 2;
    rglwidgetClass.prototype.fogExp2 = 3;

    /**
     * Methods related to obsolete approaches.
     * @name ___OBSOLETE_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
       no debug element.
     */
    rglwidgetClass.prototype.start = function() {
      if (typeof this.prefix !== "undefined") {
        this.debugelement = document.getElementById(this.prefix + "debug");
        this.debug("");
      }
      this.drag = 0;
      this.drawScene();
    };
</script>
<script>    /**
     * Utility methods
     * @name ___UTILITY_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Multiply matrix by vector
     * @returns {number[]}
     * @param M {number[][]} Left operand
     * @param v {number[]} Right operand
     */
    rglwidgetClass.multMV = function(M, v) {
        return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
                 M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
                 M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
                 M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Multiply row vector by Matrix
     * @returns {number[]}
     * @param v {number[]} left operand
     * @param M {number[][]} right operand
     */
    rglwidgetClass.multVM = function(v, M) {
        return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
                 M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
                 M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
                 M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Euclidean length of a vector
     * @returns {number}
     * @param v {number[]}
     */
    rglwidgetClass.vlen = function(v) {
      return Math.sqrt(rglwidgetClass.dotprod(v, v));
    };

    /**
     * Dot product of two vectors
     * @instance rglwidgetClass
     * @returns {number}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.dotprod = function(a, b) {
      return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    };

    /**
     * Cross product of two vectors
     * @returns {number[]}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.xprod = function(a, b) {
      return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
    };

    /**
     * Bind vectors or matrices by columns
     * @returns {number[][]}
     * @param a {number[][]}
     * @param b {number[]|number[][]}
     */
    rglwidgetClass.cbind = function(a, b) {
      if (b.length < a.length)
        b = rglwidgetClass.repeatToLen(b, a.length);
      else if (a.length < b.length)
        a = rglwidgetClass.repeatToLen(a, b.length);
      return a.map(function(currentValue, index) {
            return [].concat(currentValue).concat(b[index]);
      });
    };

    /**
     * Swap elements
     * @returns {any[]}
     * @param a {any[]}
     * @param i {number} Element to swap
     * @param j {number} Other element to swap
     */
    rglwidgetClass.swap = function(a, i, j) {
      var temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    };

    /**
     * Flatten a matrix into a vector
     * @returns {any[]}
     * @param a {any[][]}
     */
    rglwidgetClass.flatten = function(arr, result) {
      var value;
      if (typeof result === "undefined") result = [];
      for (var i = 0, length = arr.length; i < length; i++) {
        value = arr[i];
        if (Array.isArray(value)) {
          rglwidgetClass.flatten(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    };

    /**
     * set element of 1d or 2d array as if it was flattened.
     * Column major, zero based!
     * @returns {any[]|any[][]}
     * @param {any[]|any[][]} a - array
     * @param {number} i - element
     * @param {any} value
     */
    rglwidgetClass.prototype.setElement = function(a, i, value) {
      if (Array.isArray(a[0])) {
        var dim = a.length,
            col = Math.floor(i/dim),
            row = i % dim;
        a[row][col] = value;
      } else {
        a[i] = value;
      }
    };

    /**
     * Transpose an array
     * @returns {any[][]}
     * @param {any[][]} a
     */
    rglwidgetClass.prototype.transpose = function(a) {
      var newArray = [],
          n = a.length,
          m = a[0].length,
          i;
      for(i = 0; i < m; i++){
        newArray.push([]);
      }

      for(i = 0; i < n; i++){
        for(var j = 0; j < m; j++){
          newArray[j].push(a[i][j]);
        }
      }
      return newArray;
    };

    /**
     * Calculate sum of squares of a numeric vector
     * @returns {number}
     * @param {number[]} x
     */
    rglwidgetClass.prototype.sumsq = function(x) {
      var result = 0, i;
      for (i=0; i < x.length; i++)
        result += x[i]*x[i];
      return result;
    };

    /**
     * Convert a matrix to a CanvasMatrix4
     * @returns {CanvasMatrix4}
     * @param {number[][]|number[]} mat
     */
    rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
      if (mat instanceof CanvasMatrix4)
        return mat;
      var result = new CanvasMatrix4();
      mat = rglwidgetClass.flatten(this.transpose(mat));
      result.load(mat);
      return result;
    };

    /**
     * Convert an R-style numeric colour string to an rgb vector
     * @returns {number[]}
     * @param {string} s
     */
    /* jshint bitwise:false */ 
    rglwidgetClass.prototype.stringToRgb = function(s) {
      s = s.replace("#", "");
      var bigint = parseInt(s, 16);
      return [((bigint >> 16) & 255)/255,
              ((bigint >> 8) & 255)/255,
               (bigint & 255)/255];
    };
    /* jshint bitwise:true */
    /**
     * Which list does a particular id come from?
     * @returns { string }
     * @param {number} id The id to look up.
     */
    rglwidgetClass.prototype.whichList = function(id) {
      var obj = this.getObj(id),
          flags = obj.flags;
        if (obj.type === "light")
          return "lights";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_subscene))
            return "subscenes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_clipplanes))
            return "clipplanes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent))
            return "transparent";
        return "opaque";
    };
    
    /**
     * Take a component-by-component product of two 3 vectors
     * @returns {number[]}
     * @param {number[]} x
     * @param {number[]} y
     */
    rglwidgetClass.prototype.componentProduct = function(x, y) {
      if (typeof y === "undefined") {
        this.alertOnce("Bad arg to componentProduct");
      }
      var result = new Float32Array(3), i;
      for (i = 0; i<3; i++)
        result[i] = x[i]*y[i];
      return result;
    };

    /**
     * Get next higher power of two
     * @returns { number }
     * @param { number } value - input value
     */
    rglwidgetClass.prototype.getPowerOfTwo = function(value) {
      var pow = 1;
      while(pow<value) {
        pow *= 2;
      }
      return pow;
    };

    /**
     * Unique entries
     * @returns { any[] }
     * @param { any[] } arr - An array
     */
    rglwidgetClass.prototype.unique = function(arr) {
      arr = [].concat(arr);
      return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    };

    /**
     * Shallow compare of arrays
     * @returns { boolean }
     * @param { any[] } a - An array
     * @param { any[] } b - Another array
     */
    rglwidgetClass.prototype.equalArrays = function(a, b) {
      return a === b || (a && b &&
                      a.length === b.length &&
                      a.every(function(v, i) {return v === b[i];}));
    };
    
    /**
     * Repeat an array to a desired length
     * @returns {any[]}
     * @param {any | any[]} arr The input array
     * @param {number} len The desired output length
     */
    rglwidgetClass.repeatToLen = function(arr, len) {
      arr = [].concat(arr);
      if (!arr.length) 
        throw new RangeError("array is length 0");
      while (arr.length < len/2)
        arr = arr.concat(arr);
      return arr.concat(arr.slice(0, len - arr.length));
    };

    /**
     * Give a single alert message, not to be repeated.
     * @param {string} msg  The message to give.
     */
    rglwidgetClass.prototype.alertOnce = function(msg) {
      // debugger;
      if (typeof this.alerted !== "undefined")
        return;
      this.alerted = true;
      alert(msg);
    };

    /**
     * Get an object by id number.
     * @returns { Object }
     * @param {number} id
     */
    rglwidgetClass.prototype.getObj = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("getObj id is "+typeof id);
      }
      return this.scene.objects[id];
    };

    /**
     * Get ids of a particular type from a subscene or the whole scene
     * @returns { number[] }
     * @param {string} type What type of object?
     * @param {number} subscene  Which subscene?  If not given, find in the whole scene
     */
    rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
      var
        result = [], i, self = this, ids;
      if (typeof subscene === "undefined") {
        Object.keys(this.scene.objects).forEach(
          function(key) {
            key = parseInt(key, 10);
            if (self.getObj(key).type === type)
              result.push(key);
          });
      } else {
        ids = this.getObj(subscene).objects;
        for (i=0; i < ids.length; i++) {
          if (this.getObj(ids[i]).type === type) {
            result.push(ids[i]);
          }
        }
      }
      return result;
    };

    /**
     * Get a particular material property for an obj
     * @returns { any }
     * @param {object} obj  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterial = function(obj, property) {
      var mat;
      if (typeof obj.material === "undefined")
        console.error("material undefined");
      mat = obj.material[property];
      if (typeof mat === "undefined")
          mat = this.scene.material[property];
      return mat;
    };
    
   /**
     * Get a particular material property for an id
     * @returns { any }
     * @param {number} id  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterialId = function(id, property) {
      var obj = this.getObj(id);
      return this.getMaterial(obj, property);
    };

    rglwidgetClass.prototype.getAdj = function (obj, index, offset, text) {
      var len, pos;
      if (typeof obj.pos === "undefined")
        return rglwidgetClass.flatten(obj.adj);
      pos = obj.pos[index % obj.pos.length];
      switch(pos) {
        case 0: return [0.5, 0.5, 0.5];
        case 1: return [0.5, 1 + offset, 0.5];
        case 3: return [0.5, -offset, 0.5];
        case 5: return [0.5, 0.5, -offset];
        case 6: return [0.5, 0.5, 1 + offset];
        case 2: 
        case 4: if (typeof text === "undefined")
                  len = 1;
                else
                  len = text.length;
                if (pos === 2)
                  return [1 + offset/len, 0.5, 0.5];
                else
                  return [-offset/len, 0.5, 0.5];
      }
    };

    /**
     * Count clipping planes in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplanes = function() {
      var self = this,
          bound = 0;
      
      Object.keys(this.scene.objects).forEach(
        function(key) {
          var obj = self.getObj(parseInt(key, 10));
          if (obj.type === "clipplanes")
            bound = bound + obj.offsets.length;
        });
      return bound;
    };

    /**
     * Count clipping plane objects in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplaneObjs = function() {
      return this.countObjs("clipplanes");
    };

    /**
     * Count lights in a scene
     * @returns { number }
     */
    rglwidgetClass.prototype.countLights = function() {
      return this.countObjs("light");
    };

    /**
     * Count objects of specific type in a scene
     * @returns { number }
     * @param { string } type - Type of object to count
     */
    rglwidgetClass.prototype.countObjs = function(type) {
      var self = this,
          bound = 0;

      Object.keys(this.scene.objects).forEach(
        function(key) {
          if (self.getObj(parseInt(key, 10)).type === type)
            bound = bound + 1;
        });
      return bound;
    };

    /**
     * Display a debug message
     * @param { string } msg - The message to display
     * @param { Object } [img] - Image to insert before message
     */
    rglwidgetClass.prototype.debug = function(msg, img) {
      if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
        this.debugelement.innerHTML = msg;
        if (typeof img !== "undefined") {
          this.debugelement.insertBefore(img, this.debugelement.firstChild);
        }
      } else if (msg !== "")
        alert(msg);
    };

    /**
     * If we are in an ioslides or slidy presentation, get the
     * DOM element of the current slide
     * @returns { Object }
     */
    rglwidgetClass.prototype.getSlide = function() {
      var result = this.el, done = false;
      while (result && !done && this.scene.context.rmarkdown) {
      	switch(this.scene.context.rmarkdown) {
          case "ioslides_presentation":
            if (result.tagName === "SLIDE") return result;
            break;
          case "slidy_presentation":
            if (result.tagName === "DIV" && result.classList.contains("slide"))
              return result;
            break;
          default: return null;
      	}
      	result = result.parentElement;
      }
      return null;
    };

    /**
     * Is this scene visible in the browser?
     * @returns { boolean }
     */
    rglwidgetClass.prototype.isInBrowserViewport = function() {
      var rect = this.canvas.getBoundingClientRect(),
          windHeight = (window.innerHeight || document.documentElement.clientHeight),
          windWidth = (window.innerWidth || document.documentElement.clientWidth);
      if (this.scene.context && this.scene.context.rmarkdown !== null) {
      	if (this.slide)
      	  return (this.scene.context.rmarkdown === "ioslides_presentation" &&
      	          this.slide.classList.contains("current")) ||
      	         (this.scene.context.rmarkdown === "slidy_presentation" &&
      	          !this.slide.classList.contains("hidden"));
      }
      return (
      	rect.top >= -windHeight &&
      	rect.left >= -windWidth &&
      	rect.bottom <= 2*windHeight &&
      	rect.right <= 2*windWidth);
    };
    
    rglwidgetClass.keydiff = function(obj1, obj2) {
      var keys = Object.keys(obj1), i, result = [];
      for (i=0;i<keys.length;i++) {
        if (typeof obj1[keys[i]] !== "undefined" &&
            typeof obj2[keys[i]] === "undefined")
          result.push(keys[i]);
      }
      return result;
    };

    rglwidgetClass.isSet = function(flags, flag) {
      /* jshint bitwise: false */
      return (flags & flag) !== 0;
      /* jshint bitwise: true */
    };
    
    rglwidgetClass.prototype.user2window = function(p, subid) {
      var m, v = [].concat(p);
      
      this.setmvMatrix(subid);
      m = new CanvasMatrix4(this.mvMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.setprMatrix(subid);
      m = new CanvasMatrix4(this.prMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.getViewport(subid);
      v[0] = v[0]*0.5/v[3] + 0.5 + this.vp.x/this.vp.width;
      v[1] = v[1]*0.5/v[3] + 0.5 + this.vp.y/this.vp.height;
      v[2] = (1 + v[2]/v[3])*0.5;
      return v.slice(0, 3);
    };

    /**
     * Andrew's convex hull algorithm. 
     * From Wikipedia, used under Creative Commons Attribution-ShareAlike License
     * @returns { Array } Indices of convex hull points
     */
    rglwidgetClass.chull = function(points) {
      function cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
        
      points.sort(function(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      });

      var lower = [], upper = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }

      for (i = points.length - 1; i >= 0; i--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
          upper.pop();
        }
        upper.push(points[i]);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    };
    
    /**
     * Round number to given precision
     * @param { number } x
     * @param { number } digits
     * @returns { number } 
     */
    rglwidgetClass.signif = function(x, digits) { 
      return parseFloat(x.toPrecision(digits));
    };
      
    /**
     * Check for NA, NaN, undefined, or null
     * @param x
     * @returns { bool }
     */
    rglwidgetClass.missing = function(x) {
      return x !== "-Inf" && x !== "Inf" &&
             (isNaN(x) || x === null || typeof(x) === "undefined");
    };

    /**
     * Write matrix to log
     * @param M
     */
    rglwidgetClass.logMatrix = function(M) {
      console.log("matrix(c("+M.m11+","+M.m12+","+M.m13+","+M.m14+",\n"+
                              M.m21+","+M.m22+","+M.m23+","+M.m24+",\n"+
                              M.m31+","+M.m32+","+M.m33+","+M.m34+",\n"+
                              M.m41+","+M.m42+","+M.m43+","+M.m44+"), byrow=TRUE, ncol=4)");
    };
    
    /**
     * Write vector to log
     * @param {vector} v
     */
     
    rglwidgetClass.logVec3 = function(v) {
      console.log("c("+v[0]+","+v[1]+","+v[2]+")");
    };
    
    /**
     * Sum two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vsum = function(x, y) {
       var i, result = [].concat(x);
       for (i = 0; i < y.length; i++)
         result[i] += y[i];
        return result;
     };
     
    /**
     * difference of two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vdiff = function(x, y) {
        return rglwidgetClass.vsum(x, rglwidgetClass.vscale(y, -1));
     };

    /**
     * Scale a vector
     * @param {number} s
     * @param {vector} x
     */
     rglwidgetClass.vscale = function(x, s) {
       var i, result = [].concat(x);
       for (i = 0; i < x.length; i++)
         result[i] *= s;
        return result;
     };
    
    /**
     * Normalize a vector
     * @param {vector} v
     */
    rglwidgetClass.normalize = function(v) {
      return rglwidgetClass.vscale(v, 1/rglwidgetClass.vlen(v));
    };
    
    /**
     * Compute the dimensions of a regular array
     * without checking that it is regular
     */ 
    rglwidgetClass.arrayDim = function(arr) {
      var result = [];
      while (typeof arr.length !== "undefined") {
        result = result.concat(arr.length);
        arr = arr[0];
      }
      return result;
    };
</script>
<script>/**
     * Methods related to buffered data
     * @name ___METHODS_FOR_BUFFERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Detect rglBuffered object
     * @param { Object } obj - vertices or similar 
     */
    rglwidgetClass.prototype.isBuffered = function(obj) {
      return typeof obj === "string";
    };

    /* The next two functions are taken from 
     
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
     
     They were written by Mozilla Contributors and dedicated
     to the public domain under CC0. */
     
    /* Array of bytes to Base64 string decoding */
    rglwidgetClass.prototype.b64ToUint6 = function(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : 
             nChr > 96 && nChr < 123 ? nChr - 71 : 
             nChr > 47 && nChr < 58 ? nChr + 4 : 
             nChr === 43 ? 62 : 
             nChr === 47 ? 63 : 
             0;
    };

    /* jshint bitwise:false */
    rglwidgetClass.prototype.base64DecToArr = function(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
        nInLen = sB64Enc.length, 
        nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
        taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    };
    /* jshint bitwise:true */
    
    rglwidgetClass.prototype.getArrayBuffer = function(base64) {
      return this.base64DecToArr(base64, 4).buffer;
    };

    rglwidgetClass.prototype.getBufferedData = function(v) {
      return this.readAccessor(parseInt(v, 10), this.scene.buffer);
    };
    
    rglwidgetClass.prototype.readAccessor = function(acc, buf) {
      var typeSignedByte = 5120, 
          typeUnsignedByte = 5121, 
          typeSignedShort = 5122, 
          typeUnsignedShort = 5123, 
          typeSignedInt = 5124, 
          typeUnsignedInt = 5125, 
          typeFloat = 5126, 
          typeDouble = 5130, 
          accessor = buf.accessors[acc], 
          bufferView = buf.bufferViews[accessor.bufferView], 
          buffer = buf.buffers[bufferView.buffer], 
          bytes, 
          lens = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, 
          rowsizes = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 2,
            MAT3: 3,
            MAT4: 4
          }, 
          offset = 0, 
          len = lens[accessor.type], 
          rowsize = rowsizes[accessor.type], 
          count = len * accessor.count, 
          nrows = count / rowsize, 
          values, arr = [], row, i, j, k;
          
      if (typeof buffer.bytes === "string") 
        buffer.bytes = this.getArrayBuffer(buffer.bytes);
        
      bytes = buffer.bytes;
      
      if (typeof accessor.byteOffset !== "undefined") 
        offset += accessor.byteOffset;
        
      if (typeof bufferView.byteOffset !== "undefined") 
        offset += bufferView.byteOffset;
        
      switch (accessor.componentType) {
       case typeSignedByte:
        values = new Int8Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedByte:
        values = new Uint8Array(buffer.bytes, offset, count);
        break;

       case typeSignedShort:
        values = new Int16Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedShort:
        values = new Uint16Array(buffer.bytes, offset, count);
        break;

       case typeSignedInt:
        values = new Int32Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedInt:
        values = new Uint32Array(buffer.bytes, offset, count);
        break;

       case typeFloat:
        values = new Float32Array(buffer.bytes, offset, count);
        break;

       case typeDouble:
        values = new Float64Array(buffer.bytes, offset, count);
        break;
      }

      /* This is all very inefficient, but is convenient
             to work with the old code. */
      k = 0;
      for (i = 0; i < nrows; i++) {
        row = [];
        for (j = 0; j < rowsize; j++) {
          if (accessor.normalized) {
            switch(accessor.componentType) {
              case typeSignedByte:
                row.push(Math.max(values[k++]/127, -1.0));
                break;
              case typeSignedShort:
                row.push(Math.max(values[k++]/32767, -1.0));
                break;
              case typeUnsignedByte:
                row.push(values[k++]/255);
                break;
              case typeUnsignedShort:
                row.push(values[k++]/65535);
                break;
            }
          } else
            row.push(values[k++]);
        }
        arr.push(row);
      }
      return arr;
    };
    
    rglwidgetClass.prototype.expandBufferedFields = function(obj) {
      /* this list needs to match the one in convertScene.R */
      var fields = ["vertices", "normals", "indices", 
                    "texcoords", "colors", "centers"], i, field;
      for (i = 0; i < fields.length; i++) {
        field = obj[fields[i]];
        if (this.isBuffered(field))
          obj[fields[i]] = this.getBufferedData(field);
      }
    };
</script>
<script>    /**
     * Methods related to subscenes
     * @name ___METHODS_FOR_SUBSCENES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */

    /**
     * Is a particular id in a subscene?
     * @returns { boolean }
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.inSubscene = function(id, subscene) {
      return this.getObj(subscene).objects.indexOf(id) > -1;
    };

    /**
     * Translate from window coordinates to viewport coordinates
     * @returns { Object } translated coordinates
     * @param { number } subsceneid - which subscene to use?
     * @param { Object } coords - point to translate
     */
    rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
      var viewport = this.getObj(subsceneid).par3d.viewport;
      return {x: coords.x - viewport.x*this.canvas.width,
              y: coords.y - viewport.y*this.canvas.height};
    };

    /**
     * Check whether point is in viewport of subscene
     * @returns {boolean}
     * @param { Object } coords - screen coordinates of point
     * @param { number } subsceneid - subscene to check
     */
    rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
      var viewport = this.getObj(subsceneid).par3d.viewport,
        x0 = coords.x - viewport.x*this.canvas.width,
        y0 = coords.y - viewport.y*this.canvas.height;
      return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
             0 <= y0 && y0 <= viewport.height*this.canvas.height;
    };

    /**
     * Find which subscene contains a point
     * @returns { number } subscene id
     * @param { Object } coords - coordinates of point
     */
    rglwidgetClass.prototype.whichSubscene = function(coords) {
      var self = this,
          recurse = function(subsceneid) {
            var subscenes = self.getChildSubscenes(subsceneid), i, id;
            for (i=0; i < subscenes.length; i++) {
              id = recurse(subscenes[i]);
              if (typeof(id) !== "undefined")
                return(id);
            }
            if (self.inViewport(coords, subsceneid))
              return(subsceneid);
            else
              return undefined;
          },
          rootid = this.scene.rootSubscene,
          result = recurse(rootid);
      if (typeof(result) === "undefined")
        result = rootid;
      return result;
    };

    /**
     * Add an id to a subscene.
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          ids = [id],
          obj = this.getObj(id), i;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined") {
        ids = ids.concat(obj.newIds);
      }
      thesub.objects = [].concat(thesub.objects);
      for (i = 0; i < ids.length; i++) {
        id = ids[i];
        if (thesub.objects.indexOf(id) === -1) {
          thelist = this.whichList(id);
          thesub.objects.push(id);
          thesub[thelist].push(id);
        }
      }
    };

    /**
     * Delete an id from a subscene
     * @param { number } id - the id to add
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          obj = this.getObj(id),
          ids = [id], i, j;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
        ids = ids.concat(obj.newIds);
      thesub.objects = [].concat(thesub.objects); // It might be a scalar
      for (j=0; j<ids.length;j++) {
        id = ids[j];
        i = thesub.objects.indexOf(id);
        if (i > -1) {
          thesub.objects.splice(i, 1);
          thelist = this.whichList(id);
          i = thesub[thelist].indexOf(id);
          thesub[thelist].splice(i, 1);
        }
      }
    };

    /**
     * Set the ids in a subscene
     * @param { number[] } ids - the ids to set
     * @param { number } subsceneid - the id of the subscene
     */
    rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
      var sub = this.getObj(subsceneid);
      sub.objects = ids;
      this.initSubscene(subsceneid);
    };

    /**
     * Get the ids in a subscene
     * @returns {number[]}
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
      return this.getObj(subscene).objects;
    };

    /**
     * Get the ids of the subscenes within a subscene
     * @returns { number[] }
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
      return this.getObj(subscene).subscenes;
    };

    /**
     * Find a particular subscene by inheritance
     * @returns { number } id of subscene to use
     * @param { number } subsceneid - child subscene
     * @param { string } type - type of inheritance:  "projection" or "model"
     */
    rglwidgetClass.prototype.useid = function(subsceneid, type) {
      var sub = this.getObj(subsceneid);
      if (sub.embeddings[type] === "inherit")
        return(this.useid(sub.parent, type));
      else
        return subsceneid;
    };

    /**
     * Find bboxdeco for a subscene
     * @returns { number } id of bboxdeco, or undefined if none
     * @param { number } sub- subscene
     */
    rglwidgetClass.prototype.getBBoxDeco = function(sub) {
      var objects = sub.objects, i, obj;
      for (i = 0; i < objects.length; i++) {
        obj = this.getObj(objects[i]);
        if (obj.type === "bboxdeco")
          return obj;
      }
      if (sub.parent) 
        return this.getBBoxDeco(this.getObj(sub.parent));
      else
        return undefined;
    };
</script>
<script>    /**
     * Methods related to shaders
     * @name ___METHODS_FOR_SHADERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get flags that will end up as shader defines.
     * Static method so it can be called from R
     */
    rglwidgetClass.getDefFlags = function(flags, type, normals, round_points) {
      var f = {};
      f.fat_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_fat_lines);
      f.fixed_quads = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads);
      f.fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size);
      f.has_fog = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_fog);
      f.has_normals = (typeof normals !== "undefined") ||
                        type === "spheres";
      f.has_texture = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_texture);
      f.is_brush = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_brush);
      f.is_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lines);
      f.is_lit = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit);
      f.is_points = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_points);
      f.is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
      f.is_twosided = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_twosided);
      f.needs_vnormal = !rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d) &&
        (f.is_lit && !f.fixed_quads && !f.is_brush) || (f.is_twosided && f.has_normals);
      f.rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating);
      f.round_points = round_points;
      return f;
    };
     
    
    /**
     * Generate the defines for the shader code for an object.
     * 
     * This is a static method so it can be called from R.
     * 
     * @returns {string}
     * @param  id - id of object
     * @param  type - type of object
     * @param  flags - object flags
     * @param  nclipplanes - number of clipping planes in scene 
     *         (may not all be active)
     * @param  nlights - number of lights in scene (ditto)
     * @param  normals - normals for object
     * @param  pointSize - point size for object 
     * @param  textype - texture type for object 
     * @param  antialias - use antialiasing?
     */
    rglwidgetClass.getDefines = function(id, type, flags,
      nclipplanes, nlights, normals, pointSize, textype,
      texmode, texenvmap, antialias, fl) {
      var
        title, defines;
      
      if (typeof fl === "undefined")
        fl = rglwidgetClass.getDefFlags(flags, type, normals, antialias);
        
      title = "  /* ****** "+type+" object "+id+" shader ****** */\n";
      
      defines = "#define NCLIPPLANES " + nclipplanes + "\n"+
                "#define NLIGHTS " + nlights + "\n";
      
      if (fl.fat_lines)
        defines = defines + "#define FAT_LINES 1\n";
      
      if (fl.fixed_quads)
        defines = defines + "#define FIXED_QUADS 1\n";

      if (fl.fixed_size)
        defines = defines + "#define FIXED_SIZE 1\n";

      if (fl.has_fog)
        defines = defines + "#define HAS_FOG 1\n";
        
      if (fl.has_normals)
        defines = defines + "#define HAS_NORMALS 1\n";
        
      if (fl.has_texture) {
        defines = defines + "#define HAS_TEXTURE 1\n";
        defines = defines + "#define TEXTURE_" + textype + "\n";
        defines = defines + "#define TEXMODE_" + texmode + "\n";
        if (texenvmap)
          defines = defines + "#define USE_ENVMAP 1\n";
      }
      
      if (fl.is_brush)
        defines = defines + "#define IS_BRUSH 1\n";  

      if (type === "linestrip")
        defines = defines + "#define IS_LINESTRIP 1\n";         

      if (fl.is_lit)
        defines = defines + "#define IS_LIT 1\n"; 
      
      if (fl.is_points) {
        defines = defines + "#define IS_POINTS 1\n";
        defines = defines + "#define POINTSIZE " + Number.parseFloat(pointSize).toFixed(1) + "\n";
      }
        
      if (type === "sprites")
        defines = defines + "#define IS_SPRITES 1\n";
        
      if (type === "text")
        defines = defines + "#define IS_TEXT 1\n";

      if (fl.is_transparent)
        defines = defines + "#define IS_TRANSPARENT 1\n"; 
        
      if (fl.is_twosided)
        defines = defines + "#define IS_TWOSIDED 1\n";
        
      if (fl.needs_vnormal)
        defines = defines + "#define NEEDS_VNORMAL 1\n";

      if (fl.rotating)
        defines = defines + "#define ROTATING 1\n";
        
      if (fl.round_points)        
        defines = defines + "#define ROUND_POINTS 1\n";   

      // console.log(result);
      return title + defines;
    };

    /**
     * Create code for vertex and fragment shaders
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShaders = function(obj) {
      var header, 
        vertex = obj.userVertexShader, 
        fragment = obj.userFragmentShader;
      
      header = rglwidgetClass.getDefines(
        obj.id, obj.type, obj.flags, 
        this.countClipplanes(), this.countLights(), 
        obj.normals, 
        this.getMaterial(obj, "size"), 
        this.getMaterial(obj, "textype"),
        this.getMaterial(obj, "texmode"),
        this.getMaterial(obj, "texenvmap"),
        this.getMaterial(obj, "point_antialias"),
        obj.defFlags
      );

      if (typeof vertex === "undefined")
        vertex = rglwidgetClass.rgl_vertex_shader();
        
      if (typeof fragment === "undefined") 
        fragment = rglwidgetClass.rgl_fragment_shader();

//      console.log("vertex:");
//      console.log(header + vertex);
//      console.log("fragment:");
//      console.log(header + fragment);
      
      return {vertex: header + vertex,
              fragment: header + fragment};
    };
    
    
    /**
     * Call gl functions to create and compile shader from code
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShader = function(shaderType, code) {
        var gl = this.gl, shader;
        shader = gl.createShader(shaderType);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
            alert(gl.getShaderInfoLog(shader));
        return shader;
    };

</script>
<script>rglwidgetClass.rgl_vertex_shader = function() {
return  "#line 2 1\n"+
"// File 1 is the vertex shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"\n"+
"attribute vec3 aPos;\n"+
"attribute vec4 aCol;\n"+
"uniform mat4 mvMatrix;\n"+
"uniform mat4 prMatrix;\n"+
"varying vec4 vCol;\n"+
"varying vec4 vPosition;\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"attribute vec3 aNorm;\n"+
"uniform mat4 normMatrix;\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"attribute vec2 aTexcoord;\n"+
"varying vec2 vTexcoord;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_SIZE\n"+
"uniform vec3 textScale;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_QUADS\n"+
"attribute vec3 aOfs;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"varying float normz;\n"+
"uniform mat4 invPrMatrix;\n"+
"#else\n"+
"attribute vec3 aPos1;\n"+
"attribute vec3 aPos2;\n"+
"varying float normz;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"attribute vec3 aNext;\n"+
"attribute vec2 aPoint;\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"uniform float uAspect;\n"+
"uniform float uLwd;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  \n"+
"#ifndef IS_BRUSH\n"+
"#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n"+
"  vPosition = mvMatrix * vec4(aPos, 1.);\n"+
"#endif\n"+
"  \n"+
"#ifndef FIXED_QUADS\n"+
"  gl_Position = prMatrix * vPosition;\n"+
"#endif\n"+
"#endif // !IS_BRUSH\n"+
"  \n"+
"#ifdef IS_POINTS\n"+
"  gl_PointSize = POINTSIZE;\n"+
"#endif\n"+
"  \n"+
"  vCol = aCol;\n"+
"  \n"+
"// USE_ENVMAP implies NEEDS_VNORMAL\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n"+
"                        normalize(vNormal.xyz/vNormal.w)));\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"  /* normz should be calculated *after* projection */\n"+
"  normz = (invPrMatrix*vNormal).z;\n"+
"#else\n"+
"  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"  \n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n"+
"#endif\n"+
"  \n"+
"#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n"+
"  vTexcoord = aTexcoord;\n"+
"#endif\n"+
"  \n"+
"#if defined(FIXED_SIZE) && !defined(ROTATING)\n"+
"  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w;\n"+
"  gl_Position = pos + vec4(aOfs*textScale, 0.);\n"+
"#endif\n"+
"  \n"+
"#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n"+
"  vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w + vec4(aOfs,  0.);\n"+
"  gl_Position = prMatrix*pos;\n"+
"#endif\n"+
"  \n"+
"#ifdef FAT_LINES\n"+
"  /* This code was inspired by Matt Deslauriers' code in \n"+
"   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n"+
"  vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"  mat4 projViewModel = prMatrix * mvMatrix;\n"+
"  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"  currentProjected = currentProjected/currentProjected.w;\n"+
"  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"  vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"  float len = uLwd;\n"+
"  vec2 dir = vec2(1.0, 0.0);\n"+
"  vPoint = aPoint;\n"+
"  vLength = length(nextScreen - currentScreen)/2.0;\n"+
"  vLength = vLength/(vLength + len);\n"+
"  if (vLength > 0.0) {\n"+
"    dir = normalize(nextScreen - currentScreen);\n"+
"  }\n"+
"  vec2 normal = vec2(-dir.y, dir.x);\n"+
"  dir.x /= uAspect;\n"+
"  normal.x /= uAspect;\n"+
"  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"  gl_Position = currentProjected + offset;\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_BRUSH\n"+
"  gl_Position = vec4(aPos, 1.);\n"+
"#endif\n"+
"}\n" ;};
rglwidgetClass.rgl_fragment_shader = function() {
return  "#line 2 2\n"+
"// File 2 is the fragment shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"varying vec4 vCol; // carries alpha\n"+
"varying vec4 vPosition;\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"varying vec2 vTexcoord;\n"+
"uniform sampler2D uSampler;\n"+
"#endif\n"+
"\n"+
"#ifdef HAS_FOG\n"+
"uniform int uFogMode;\n"+
"uniform vec3 uFogColor;\n"+
"uniform vec4 uFogParms;\n"+
"#endif\n"+
"\n"+
"#if defined(IS_LIT) && !defined(FIXED_QUADS)\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if NCLIPPLANES > 0\n"+
"uniform vec4 vClipplane[NCLIPPLANES];\n"+
"#endif\n"+
"\n"+
"#if NLIGHTS > 0\n"+
"uniform mat4 mvMatrix;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"uniform vec3 emission;\n"+
"uniform float shininess;\n"+
"#if NLIGHTS > 0\n"+
"uniform vec3 ambient[NLIGHTS];\n"+
"uniform vec3 specular[NLIGHTS]; // light*material\n"+
"uniform vec3 diffuse[NLIGHTS];\n"+
"uniform vec3 lightDir[NLIGHTS];\n"+
"uniform bool viewpoint[NLIGHTS];\n"+
"uniform bool finite[NLIGHTS];\n"+
"#endif\n"+
"#endif // IS_LIT\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"uniform bool front;\n"+
"varying float normz;\n"+
"#endif\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  vec4 fragColor;\n"+
"#ifdef FAT_LINES\n"+
"  vec2 point = vPoint;\n"+
"  bool neg = point.y < 0.0;\n"+
"  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n"+
"                 -(point.y - vLength)/(1.0 - vLength);\n"+
"#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n"+
"  if (neg && length(point) <= 1.0) discard;\n"+
"#endif\n"+
"  point.y = min(point.y, 0.0);\n"+
"  if (length(point) > 1.0) discard;\n"+
"#endif // FAT_LINES\n"+
"  \n"+
"#ifdef ROUND_POINTS\n"+
"  vec2 coord = gl_PointCoord - vec2(0.5);\n"+
"  if (length(coord) > 0.5) discard;\n"+
"#endif\n"+
"  \n"+
"#if NCLIPPLANES > 0\n"+
"  for (int i = 0; i < NCLIPPLANES; i++)\n"+
"    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n"+
"#endif\n"+
"    \n"+
"#ifdef FIXED_QUADS\n"+
"    vec3 n = vec3(0., 0., 1.);\n"+
"#elif defined(IS_LIT)\n"+
"    vec3 n = normalize(vNormal.xyz);\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TWOSIDED\n"+
"    if ((normz <= 0.) != front) discard;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n"+
"    vec3 lightdir;\n"+
"    vec4 colDiff;\n"+
"    vec3 halfVec;\n"+
"    vec4 lighteffect = vec4(emission, 0.);\n"+
"    vec3 col;\n"+
"    float nDotL;\n"+
"#ifdef FIXED_QUADS\n"+
"    n = -faceforward(n, n, eye);\n"+
"#endif\n"+
"    \n"+
"#if NLIGHTS > 0\n"+
"    for (int i=0;i<NLIGHTS;i++) {\n"+
"      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n"+
"      lightdir = lightDir[i];\n"+
"      if (!viewpoint[i])\n"+
"        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"      if (!finite[i]) {\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      } else {\n"+
"        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      }\n"+
"      col = ambient[i];\n"+
"      nDotL = dot(n, lightdir);\n"+
"      col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n"+
"      lighteffect = lighteffect + vec4(col, colDiff.a);\n"+
"    }\n"+
"#endif\n"+
"    \n"+
"#else // not IS_LIT\n"+
"    vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TEXT\n"+
"    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"    \n"+
"#ifdef HAS_TEXTURE\n"+
"\n"+
"// These calculations use the definitions from \n"+
"// https://docs.gl/gl3/glTexEnv\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n"+
"    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n"+
"#else\n"+
"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXTURE_rgb\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(textureColor.rgb, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif //TEXTURE_rgb\n"+
"        \n"+
"#ifdef TEXTURE_rgba\n"+
"\n"+
"#ifdef TEXMODE_replace\n"+
"// already done\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*textureColor;\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_decal\n"+
"    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n"+
"                     textureColor.a*textureColor.rgb, \n"+
"                     lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"    \n"+
"#endif //TEXTURE_rgba\n"+
"    \n"+
"#ifdef TEXTURE_alpha\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(lighteffect.rgb, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n"+
"    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n"+
"#endif\n"+
" \n"+
"#endif\n"+
"    \n"+
"// The TEXTURE_luminance values are not from that reference    \n"+
"#ifdef TEXTURE_luminance\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance\n"+
" \n"+
"    \n"+
"#ifdef TEXTURE_luminance_alpha\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance_alpha\n"+
"    \n"+
"    fragColor = textureColor;\n"+
"\n"+
"#elif defined(IS_TEXT)\n"+
"    if (textureColor.a < 0.1)\n"+
"      discard;\n"+
"    else\n"+
"      fragColor = textureColor;\n"+
"#else\n"+
"    fragColor = lighteffect;\n"+
"#endif // HAS_TEXTURE\n"+
"    \n"+
"#ifdef HAS_FOG\n"+
"    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n"+
"    // In Exp and Exp2: use density = density/far\n"+
"    // fogF will be the proportion of fog\n"+
"    // Initialize it to the linear value\n"+
"    float fogF;\n"+
"    if (uFogMode > 0) {\n"+
"      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n"+
"      if (uFogMode > 1)\n"+
"        fogF = mix(uFogParms.w, 1.0, fogF);\n"+
"      fogF = fogF*uFogParms.z;\n"+
"      if (uFogMode == 2)\n"+
"        fogF = 1.0 - exp(-fogF);\n"+
"      // Docs are wrong: use (density*c)^2, not density*c^2\n"+
"      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n"+
"      else if (uFogMode == 3)\n"+
"        fogF = 1.0 - exp(-fogF*fogF);\n"+
"      fogF = clamp(fogF, 0.0, 1.0);\n"+
"      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n"+
"    } else gl_FragColor = fragColor;\n"+
"#else\n"+
"    gl_FragColor = fragColor;\n"+
"#endif // HAS_FOG\n"+
"    \n"+
"}\n" ;};
</script>
<script>    /**
     * Methods related to textures
     * @name ___METHODS_FOR_TEXTURES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getTexFilter = function(filter) {
      var gl = this.gl || this.initGL();
      switch(filter) {
        case "nearest": return gl.NEAREST;
        case "linear": return gl.LINEAR;
        case "nearest.mipmap.nearest": return gl.NEAREST_MIPMAP_NEAREST;
        case "linear.mipmap.nearest": return gl.LINEAR_MIPMAP_NEAREST;
        case "nearest.mipmap.linear": return gl.NEAREST_MIPMAP_LINEAR;
        case "linear.mipmap.linear": return gl.LINEAR_MIPMAP_LINEAR;
        default: console.error("Unknown filter: "+filter);
      }
    };
     
    /**
     * Handle a texture after its image has been loaded
     * @param { Object } texture - the gl texture object
     * @param { Object } textureCanvas - the canvas holding the image
     */
    rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
      var gl = this.gl || this.initGL();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
    };

    /**
     * Get maximum dimension of texture in current browser.
     * @returns {number}
     */
    rglwidgetClass.prototype.getMaxTexSize = function() {
      var gl = this.gl || this.initGL();	
      return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
    };
    
    /**
     * Load an image to a texture
     * @param { string } uri - The image location
     * @param { Object } texture - the gl texture object
     */
    rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
      var canvas = this.textureCanvas,
          ctx = canvas.getContext("2d"),
          image = new Image(),
          self = this;

       image.onload = function() {

         var w = image.width,
             h = image.height,
             canvasX = self.getPowerOfTwo(w),
             canvasY = self.getPowerOfTwo(h),
             maxTexSize = self.getMaxTexSize();
         while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
           canvasX /= 2;
           canvasY /= 2;
         }
         canvas.width = canvasX;
         canvas.height = canvasY;
         ctx.imageSmoothingEnabled = true;
         ctx.drawImage(image, 0, 0, canvasX, canvasY);
         self.handleLoadedTexture(texture, canvas);
         self.texturesLoading -= 1;
         if (!self.texturesLoading)
           self.drawScene();
       };
       if (!self.texturesLoading)
         self.texturesLoading = 0; // may have been undefined
       self.texturesLoading += 1;
       image.src = uri;
     };

    /**
     * Draw text to the texture canvas
     * @returns { Object } object with text measurements
     * @param { string } text - the text
     * @param { number } cex - expansion
     * @param { string } family - font family
     * @param { number } font - font number
     */
    rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
       var canvasX, canvasY,
           scaling = 20,
           textColour = "white",

           backgroundColour = "rgba(0,0,0,0)",
           canvas = this.textureCanvas,
           ctx = canvas.getContext("2d"),
           i, textHeight = 0, textHeights = [], width, widths = [], 
           offsetx, offsety = 0, line, lines = [], offsetsx = [],
           offsetsy = [], lineoffsetsy = [], fontStrings = [],
           maxTexSize = this.getMaxTexSize(),
           getFontString = function(i) {
             textHeights[i] = scaling*cex[i];
             var fontString = textHeights[i] + "px",
                 family0 = family[i],
                 font0 = font[i];
             if (family0 === "sans")
               family0 = "sans-serif";
             else if (family0 === "mono")
               family0 = "monospace";
             fontString = fontString + " " + family0;
             if (font0 === 2 || font0 === 4)
               fontString = "bold " + fontString;
             if (font0 === 3 || font0 === 4)
               fontString = "italic " + fontString;
             return fontString;
           };
       cex = rglwidgetClass.repeatToLen(cex, text.length);
       family = rglwidgetClass.repeatToLen(family, text.length);
       font = rglwidgetClass.repeatToLen(font, text.length);

       canvasX = 1;
       line = -1;
       offsetx = maxTexSize;
       for (i = 0; i < text.length; i++)  {
         ctx.font = fontStrings[i] = getFontString(i);
         width = widths[i] = ctx.measureText(text[i]).width;
         if (offsetx + width > maxTexSize) {
           offsety = offsety + 2*textHeight;
           if (line >= 0)
             lineoffsetsy[line] = offsety;
           line += 1;
           if (offsety > maxTexSize)
             console.error("Too many strings for texture.");
           textHeight = 0;
           offsetx = 0;
         }
         textHeight = Math.max(textHeight, textHeights[i]);
         offsetsx[i] = offsetx;
         offsetx += width;
         canvasX = Math.max(canvasX, offsetx);
         lines[i] = line;
       }
       offsety = lineoffsetsy[line] = offsety + 2*textHeight;
       for (i = 0; i < text.length; i++) {
       	 offsetsy[i] = lineoffsetsy[lines[i]];
       }
       
       canvasX = this.getPowerOfTwo(canvasX);
       canvasY = this.getPowerOfTwo(offsety);

       canvas.width = canvasX;
       canvas.height = canvasY;

       ctx.fillStyle = backgroundColour;
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

       ctx.textBaseline = "alphabetic";
       for(i = 0; i < text.length; i++) {
         ctx.font = fontStrings[i];
         ctx.fillStyle = textColour;
         ctx.textAlign = "left";
         ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
       }
       return {canvasX:canvasX, canvasY:canvasY,
               widths:widths, textHeights:textHeights,
               offsetsx:offsetsx, offsetsy:offsetsy};
     };

</script>
<script>    /**
     * Methods related to projections
     * @name ___METHODS_FOR_PROJECTIONS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get the viewport
     */
     
    rglwidgetClass.prototype.getViewport = function(id) {
      var vp = this.getObj(id).par3d.viewport,
         x = vp.x*this.canvas.width,
         y = vp.y*this.canvas.height,
         width = vp.width*this.canvas.width,
         height = vp.height*this.canvas.height;
       this.vp = {x:x, y:y, width:width, height:height};
    };
    
    /**
     * Set the gl viewport and scissor test
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setViewport = function(id) {
       var gl = this.gl || this.initGL();
       this.getViewport(id);
       gl.viewport(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.scissor(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.enable(gl.SCISSOR_TEST);
     };

    /**
     * Set the projection matrix for a subscene
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setprMatrix = function(id) {
       var subscene = this.getObj(id),
          embedding = subscene.embeddings.projection;
       if (embedding === "replace")
         this.prMatrix.makeIdentity();
       else
         this.setprMatrix(subscene.parent);
       if (embedding === "inherit")
         return;
       // This is based on the Frustum::enclose code from geom.cpp
       var bbox = subscene.par3d.bbox,
           scale = subscene.par3d.scale,
           ranges = [(bbox[1]-bbox[0])*scale[0]/2,
                     (bbox[3]-bbox[2])*scale[1]/2,
                     (bbox[5]-bbox[4])*scale[2]/2],
           radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
       if (radius <= 0) radius = 1;
       var observer = subscene.par3d.observer,
           distance = observer[2],
           FOV = subscene.par3d.FOV, ortho = FOV === 0,
           t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
           near = distance - radius,
           far = distance + radius,
           hlen,
           aspect = this.vp.width/this.vp.height,
           z = subscene.par3d.zoom,
           userProjection = subscene.par3d.userProjection;
       if (far < 0.0)
         far = 1.0;
       if (near < far/100.0)
         near = far/100.0;
       this.frustum = {near:near, far:far};
       hlen = t*near;
       if (ortho) {
         if (aspect > 1)
           this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.ortho(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       } else {
         if (aspect > 1)
           this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.frustum(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       }
       this.prMatrix.multRight(userProjection);
     };

    /**
     * Set the model-view matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmvMatrix = function(id) {
       var observer = this.getObj(id).par3d.observer;
       this.mvMatrix.makeIdentity();
       this.setmodelMatrix(id);
       this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);

     };

    /**
     * Set the model matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmodelMatrix = function(id) {
      var subscene = this.getObj(id),
          embedding = subscene.embeddings.model;
      if (embedding === "replace") {
        var bbox = subscene.par3d.bbox,
            center = [(bbox[0]+bbox[1])/2,
                      (bbox[2]+bbox[3])/2,
                      (bbox[4]+bbox[5])/2];
        this.mvMatrix.translate(-center[0], -center[1], -center[2]);
      }
      if (embedding !== "inherit") {
        var scale = subscene.par3d.scale;
        this.mvMatrix.scale(scale[0], scale[1], scale[2]);
        this.mvMatrix.multRight( subscene.par3d.userMatrix );
      }
      if (embedding !== "replace")
        this.setmodelMatrix(subscene.parent);
     };

    /**
     * Set the normals matrix for a subscene
     * @param { number } subsceneid - id of the subscene
     */
     rglwidgetClass.prototype.setnormMatrix2 = function() {
       this.normMatrix = new CanvasMatrix4(this.mvMatrix);
       this.normMatrix.invert();
       this.normMatrix.transpose();
     };

    /**
     * Set the combined projection-model-view matrix
     */
    rglwidgetClass.prototype.setprmvMatrix = function() {
       this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
       this.prmvMatrix.multRight( this.prMatrix );
     };

    rglwidgetClass.prototype.setInvPrMatrix = function() {
      this.invPrMatrix = new CanvasMatrix4( this.prMatrix );
      this.invPrMatrix.invert();
      this.invPrMatrix.transpose();
    };
</script>
<script>    /**
     * Methods related to mouse handling
     * @name ___METHODS_FOR_MOUSE_HANDLING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getCursor = function(mode) {
      switch(mode) {
        case "none": 
          return "none";
        case "trackball":
        case "xAxis":
        case "yAxis":
        case "zAxis":
        case "polar":
          return "grab";
        case "selecting":
          return "crosshair";
        case "fov":
        case "zoom":
          return "zoom-in";
        case "user":
          return "default";
      }
      return "dragging";
    };
    
    /**
     * Set mouse mode for a subscene
     * @param { string } mode - name of mode
     * @param { number } button - button number (0 to 4)
     * @param { number } subscene - subscene id number
     * @param { number } stayActive - if truthy, don't clear brush
     */
    rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
      var sub = this.getObj(subscene),
          which = ["none", "left", "right", "middle", "wheel"][button];
      if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
        this.clearBrush(null);
      sub.par3d.mouseMode[which] = mode;
      if (button === 1 || (button === 0 && mode !== "none"))
        this.canvas.style.cursor = this.getCursor(mode);
      if (button === 0 && mode !== "none")
        sub.needsBegin = mode;
    };

    /**
     * Compute mouse coordinates relative to current canvas
     * @returns { Object }
     * @param { Object } event - event object from mouse click
     */
    rglwidgetClass.prototype.relMouseCoords = function(event) {
      var rect = this.canvas.getBoundingClientRect();
      return {x:event.clientX-rect.left, y:event.clientY-rect.top};
    };
    
    /**
     * Send mouse selection to Shiny
     */
    rglwidgetClass.prototype.recordSelection = function(subid) {
      var result = {};
      if (typeof this.select !== "undefined" && 
          typeof this.select.state !== "undefined" &&
          this.select.state !== "inactive") {
        result = { subscene: subid,
                   state: this.select.state,
                   region: this.select.region
                 };
        this.setmvMatrix(subid);
        result.model = this.mvMatrix;
        this.setprMatrix(subid);
        result.proj = this.prMatrix;
        this.getViewport(subid);
        result.view = this.vp;
      } else
        result.state = "inactive";
      Shiny.setInputValue(this.scene.selectionInput + ":shinyMouse3d", result);
    }; 

    /**
     * Set mouse handlers for the scene
     */
    rglwidgetClass.prototype.setMouseHandlers = function() {
      var self = this, activeSubscene, handler,
          handlers = {}, drag = 0;

      handlers.rotBase = 0;

      self.screenToVector = function(x, y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
          radius = Math.max(width, height)/2.0,
          cx = width/2.0,
          cy = height/2.0,
          px = (x-cx)/radius,
          py = (y-cy)/radius,
          plen = Math.sqrt(px*px+py*py);
        if (plen > 1.e-6) {
          px = px/plen;
          py = py/plen;
        }
        var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
          z = Math.sin(angle),
          zlen = Math.sqrt(1.0 - z*z);
        px = px * zlen;
        py = py * zlen;
        return [px, py, z];
      };

      handlers.trackballdown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.rotBase = self.screenToVector(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.trackballmove = function(x,y) {
        var rotCurrent = self.screenToVector(x,y),
            rotBase = handlers.rotBase,
            dot = rotBase[0]*rotCurrent[0] +
                  rotBase[1]*rotCurrent[1] +
                  rotBase[2]*rotCurrent[2],
            angle = Math.acos( dot/rglwidgetClass.vlen(rotBase)/rglwidgetClass.vlen(rotCurrent) )*180.0/Math.PI,
            axis = rglwidgetClass.xprod(rotBase, rotCurrent),
            objects = self.scene.objects,
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            i;
        if (angle === 0.0)
          return;    
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
        }
        self.drawScene();
      };
      handlers.trackballend = 0;

      self.clamp = function(x, lo, hi) {
      	return Math.max(lo, Math.min(x, hi));
      };

      self.screenToPolar = function(x,y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
    	  r = Math.min(width, height)/2,
    	  dx = self.clamp(x - width/2, -r, r),
    	  dy = self.clamp(y - height/2, -r, r);
    	  return [Math.asin(dx/r), Math.asin(-dy/r)];
      };

      handlers.polardown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.dragBase = self.screenToPolar(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
          activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
                               Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.polarmove = function(x,y) {
        var dragCurrent = self.screenToPolar(x,y),
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            objects = self.scene.objects,
            l = activeModel.par3d.listeners,
            i, j, changepos = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          for (j=0; j<2; j++)
            changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
          activeSub.par3d.userMatrix.makeIdentity();
          activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
          activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
        }
        self.drawScene();
      };
      handlers.polarend = 0;

      handlers.axisdown = function(x) {
        handlers.rotBase = self.screenToVector(x, self.canvas.height/2);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.axismove = function(x) {
        var rotCurrent = self.screenToVector(x, self.canvas.height/2),
            rotBase = handlers.rotBase,
            angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
            rotMat = new CanvasMatrix4();
        rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(activeSub.saveMat);
          activeSub.par3d.userMatrix.multLeft(rotMat);
        }
        self.drawScene();
      };
      handlers.axisend = 0;

      handlers.y0zoom = 0;
      handlers.zoomdown = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        handlers.y0zoom = y;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.zoommove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/self.canvas.height);
        }
        self.drawScene();
      };
      handlers.zoomend = 0;

      handlers.y0fov = 0;
      handlers.fovdown = function(x, y) {
        handlers.y0fov = y;
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.fov0 = activeSub.par3d.FOV;
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.fovmove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
             180*(y-handlers.y0fov)/self.canvas.height));
        }
        self.drawScene();
      };
      handlers.fovend = 0;
      
      handlers.selectingdown = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height, 
          p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	self.select.region = {p1: p, p2: p};
      	if (self.select.subscene && self.select.subscene !== activeSubscene)
      	  self.delFromSubscene(self.scene.brushId, self.select.subscene);
      	self.select.subscene = activeSubscene;
      	self.addToSubscene(self.scene.brushId, activeSubscene);
      	self.select.state = "changing";
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene); 
      	self.drawScene();
      	self.canvas.style.cursor = "crosshair";
      };
      
      handlers.selectingmove = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height;
      	if (self.select.state === "inactive") 
      	  return;
      	self.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene);
      	self.drawScene();
      };
      
      handlers.selectingend = 0;
      /* jshint evil:true */
      handlers.userdown = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].begin;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.usermove = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].update;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.userend = function() {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].end;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self);
        }
      };

      self.canvas.onpointerdown = function ( ev ){
        // pointers and mice differ in capture rules; 
        // act like a mouse.
        if (ev.target.hasPointerCapture(ev.pointerId))
          ev.target.releasePointerCapture(ev.pointerId);
          
        if (!ev.which) // Use w3c defns in preference to MS
        switch (ev.button) {
          case 0: ev.which = 1; break;
          case 1:
          case 4: ev.which = 2; break;
          case 2: ev.which = 3;
        }
        drag = ["none", "left", "middle", "right", "wheel"][ev.which];
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height-coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f;
        handler = sub.par3d.mouseMode[drag];
        switch (handler) {
        case "xAxis":
          handler = "axis";
          handlers.axis = [1.0, 0.0, 0.0];
          break;
        case "yAxis":
          handler = "axis";
          handlers.axis = [0.0, 1.0, 0.0];
          break;
        case "zAxis":
          handler = "axis";
          handlers.axis = [0.0, 0.0, 1.0];
          break;
        }
        f = handlers[handler + "down"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
          ev.preventDefault();
        } else
          console.warn("Mouse handler '" + handler + "' is not implemented.");

      };

      self.canvas.onpointerup = function ( ev ){
        if ( !drag ) return;
        var f = handlers[handler + "end"];
        if (f) {
          f.call(self);
          ev.preventDefault();
        }
        drag = 0;
        handlers.onpointermove( ev );
      };

      self.canvas.onpointerout = self.canvas.onpointerup;

      handlers.onpointermove = function ( ev ) {
        var coords = self.relMouseCoords(ev), sub, f;
        coords.y = self.canvas.height - coords.y;
        if (ev.buttons === 0) {
          activeSubscene = self.whichSubscene(coords);
          drag = "none";
          sub = self.getObj(activeSubscene);
          handler = sub.par3d.mouseMode.none;
          if (handler !== "none") {
            if (sub.needsBegin) {
              f = handlers[handler + "down"];
              if (f) {
                coords = self.translateCoords(activeSubscene, coords);
                f.call(self, coords.x, coords.y);
              }
              sub.needsBegin = 0;
            }
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.none);
          } else {
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.left);  
            return;
          }
        }
        f = handlers[handler + "move"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
        }
      };
      

      self.canvas.onpointerenter = function() {
        self.canvas.addEventListener("pointermove",               handlers.onpointermove);
      };
      
      self.canvas.onpointerleave = function() {
        self.canvas.removeEventListener("pointermove",
          handlers.onpointermove);
      };

      handlers.setZoom = function(ds) {
        var i;
        if (typeof activeSubscene === "undefined")
          activeSubscene = self.scene.rootSubscene;
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            l = activeProjection.par3d.listeners;

        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom *= ds;
        }
        self.drawScene();
      };
      
      handlers.pushwheel = function(ev) {
        ev.deltaY = -ev.deltaY;
        handlers.pullwheel(ev);
      };
      
      handlers.pullwheel = function(ev) {
        var del = 1.05;
        if (ev.shiftKey) del = 1.005;
        var ds = ev.deltaY < 0 ? del : (1 / del);
        handlers.setZoom(ds);
      };
      
      handlers.user2wheel = function(ev) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks.wheel.rotate;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
          fn.call(self, ev.deltaY < 0 ? 1 : 2);
        }        
      };
        
      handlers.wheelHandler = function(ev) {
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height - coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f,
            handler = sub.par3d.mouseMode.wheel,
            evlocal;
            
        ev.deltaY = ev.deltaY || ev.detail || ev.deltaX || ev.wheelDelta;
                      
        switch(handler) {
          case "none": break;
          case "push":
          case "pull":
          case "user2":
            f = handlers[handler + "wheel"];
            if (f) {
              evlocal = {};
              evlocal.deltaY = ev.deltaY;
              evlocal.shiftKey = ev.shiftKey;
              evlocal.preventDefault = function() { ev.preventDefault(); };
              f.call(self, evlocal);
            }
            break;
          default: 
            evlocal = {};
            evlocal.preventDefault = function() { ev.preventDefault(); };
            evlocal.which = 4;
            evlocal.clientX = self.canvas.width/2;
            evlocal.clientY = self.canvas.height/2;
            self.canvas.onpointerdown(evlocal);
            evlocal.clientX += ev.deltaX;
            evlocal.clientY += ev.deltaY;
            handlers.onpointermove(evlocal);
            self.canvas.onpointerup(evlocal);
        }
        ev.preventDefault();
      };
      
      handlers.get_finger_dist = function(ev) {
        var diffX = ev.touches[0].clientX - ev.touches[1].clientX,
            diffY = ev.touches[0].clientY - ev.touches[1].clientY;
        return Math.sqrt(diffX * diffX + diffY * diffY); 
      };
      
      handlers.touchstart = function(ev) {
        var touch = ev.touches[0],
          mouseEvent = new MouseEvent("pointerdown",
            {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
        ev.preventDefault();
        if (ev.touches.length === 2) {
          var coords = self.relMouseCoords(touch);
          coords.y = self.canvas.height-coords.y;
          activeSubscene = self.whichSubscene(coords);
          handlers.finger_dist0 = handlers.get_finger_dist(ev);
          handlers.zoomdown(coords.x, coords.y);
        }
        self.dispatchEvent(mouseEvent);
      };
      
      handlers.touchend = function(ev) {
        var mouseEvent;
        ev.preventDefault();
        if (ev.touches.length === 1) {
          mouseEvent = new MouseEvent("pointerup", {});
          self.dispatchEvent(mouseEvent);
        }
      };
      
      handlers.touchmove = function(ev) {
        var touch = ev.touches[0],
          mouseEvent;
        ev.preventDefault();
        if (ev.touches.length > 1) {
          var coords = self.relMouseCoords(touch),
              new_dist = handlers.get_finger_dist(ev);
          coords.y = self.canvas.height*Math.log(handlers.finger_dist0/new_dist) + handlers.y0zoom;
          handlers.zoommove(coords.x, coords.y);
        } else {
          mouseEvent = new MouseEvent("pointermove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          self.dispatchEvent(mouseEvent);
        }
      };

      self.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
      self.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
      self.canvas.addEventListener("touchstart", handlers.touchstart, {passive: false});
      self.canvas.addEventListener("touchend", handlers.touchend, {passive: false});
      self.canvas.addEventListener("touchmove", handlers.touchmove, {passive: false});
	  };
</script>
<script>    /**
     * Methods related to initialization
     * @name ___METHODS_FOR_INITIALIZATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Initial test for WebGL
     */
    rglwidgetClass.prototype.initGL0 = function() {
      if (!window.WebGLRenderingContext){
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org");
        return;
      }
    };

    /**
     * Initialize WebGL
     * @returns { Object } the WebGL context
     */
    rglwidgetClass.prototype.initGL = function() {
      var self = this, success = false;
      if (this.gl) {
      	if (!this.drawing && this.gl.isContextLost())
          this.restartCanvas();
        else
          return this.gl;
      }
      // if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
      this.canvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      this.canvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
               this.canvas.getContext("experimental-webgl", this.webGLoptions);
      success = !!(this.gl && this.gl instanceof WebGLRenderingContext);
      if (!success)
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org"); 
      this.index_uint = this.gl.getExtension("OES_element_index_uint");
      var save = this.startDrawing();
      Object.keys(this.scene.objects).forEach(function(key){
        self.initObjId(parseInt(key, 10));
        });
      this.stopDrawing(save);
      return this.gl;
    };

    /**
     * Resize the display to match element
     * @param { Object } el - DOM element to match
     */
    rglwidgetClass.prototype.resize = function(el) {
      this.canvas.width = el.width;
      this.canvas.height = el.height;
    };

    /**
     * Initialize the sphere object
     */
    rglwidgetClass.prototype.initSphere = function(sections, segments) {
      var v = [], phi = [], theta = [], it = [], centers = [],
           i, j, k, ind, result = {};
       
      for (i = 0; i <= sections; i++) {
        phi.push(i/sections - 0.5);
      }

      for (j = 0; j <= segments; j++) {
        theta.push(2*j/segments);
        for (i = 0; i <= sections; i++) {
          /* These are [x,y,z,s,t]: */
          v.push([Math.sin(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),
                  Math.sin(Math.PI*phi[i]),
                  Math.cos(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),                               
                  theta[j]/2,
                  phi[i] + 0.5]);
           // console.log("xyzst="+v[v.length-1]);
        }
      }
      result.values = new Float32Array(rglwidgetClass.flatten(v));
      result.vertexCount = v.length;
      
      for (j = 0; j < segments; j++) {
        for (i = 0; i < sections; i++) {
          ind = i + (sections + 1)*j;
          if (i > 0)                       // Not south pole
            it.push([ind, 
                     ind + sections + 1,
                     ind + 1]);
          if (i < sections - 1)             // Not north pole
            it.push([ind + sections + 1, 
                     ind + sections + 2,
                     ind + 1]);
        }
      }
      result.it = new Uint16Array(rglwidgetClass.flatten(it));
      
      for (i = 0; i < it.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 3; k++) {// vertices
            centers[i][j] += v[it[i][k]][j]/3;
          }
        }
      }
      result.centers = centers;
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:0, radofs:-1, oofs:-1,
                         tofs:3, nextofs:-1, pointofs:-1, stride:5};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "sphere";
      this.sphere = result;
      this.initShapeGL(this.sphere);
    };

    /**
     * Initialize the cube object
     */
    rglwidgetClass.prototype.initCube = function() {
   var v = [[0, 0, 0], [1, 0, 0], 
            [0, 1, 0], [1, 1, 0], 
            [0, 0, 1], [1, 0, 1],
            [0, 1, 1], [1, 1, 1]],
          ib = [[0, 2, 3, 1], 
                [2, 6, 7, 3], 
                [1, 3, 7, 5], 
                [0, 4, 6, 2], 
                [0, 1, 5, 4], 
                [4, 5, 7, 6]], 
          centers = [], i, j, k, 
          i0, i1, i2,
          normal, result = {};
       
      for (i = 0; i < ib.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 4; k++) {// vertices
            centers[i][j] += v[ib[i][k]][j]/4;
          }
        }
      }
      result.centers = centers; 
      result.values = new Float32Array(6*4*3*2);
      result.vertexCount = 24;
      result.vertices = new Array(24);
      result.normals = new Array(24);
      for (i=0; i < 6; i++) {
        for (j=0; j < 4; j++) {
          i0 = ib[i][j];
          result.vertices[4*i + j] = v[i0];
          i1 = ib[i][(j + 1) % 4];
          i2 = ib[i][(j + 2) % 4];
          if (j === 0)
            normal = rglwidgetClass.normalize(rglwidgetClass.xprod(rglwidgetClass.vdiff(v[i1], v[i0]),
                                  rglwidgetClass.vdiff(v[i2], v[i0])));
          result.normals[4*i + j] = normal;
          for (k=0; k < 3; k++) {
            result.values[i*24 + j*6 + k] = v[i0][k];
            result.values[i*24 + j*6 + 3 + k] = normal[k];
          }
        }
        for (j=0; j<4; j++)
          ib[i][j] = 4*i + j;
      }
      result.ib = new Uint16Array(rglwidgetClass.flatten(ib));
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:3, radofs:-1, oofs:-1,
                         tofs:-1, nextofs:-1, pointofs:-1, stride:6};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "quads";
      this.cube = result;
      this.initShapeGL(this.cube);
    };
    

    /**
     * Do the gl part of initializing the sphere and cube
     */
    rglwidgetClass.prototype.initShapeGL = function(shape) {
      var gl = this.gl || this.initGL();
      if (gl.isContextLost()) return;
      shape.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, shape.buf);
      gl.bufferData(gl.ARRAY_BUFFER, shape.values, gl.STATIC_DRAW);
      shape.ibuf = [gl.createBuffer(), gl.createBuffer()];
      return;
    };

    /* Initialize common sphere object from spheres object
    */
    rglwidgetClass.prototype.initShapeFromObj = function(shape, obj) {
      var i, pass, f, mode, self = this,
        /* This function selects things that would be
           the back, ignoring perspective -- this is what 
           we want for the bounding box decoration. */
        is_back = function(i) {
                var normal = [].concat(shape.normals[i]),
                  pt = shape.vertices[i];
                normal.push(-rglwidgetClass.dotprod(normal, pt));
                normal = rglwidgetClass.multVM(normal, self.normMatrix);
                return normal[2] < 0 || (normal[2] === 0 && normal[0] < 0);
              }; 
      shape.ofsLoc = obj.ofsLoc;
      shape.texLoc = obj.texLoc;
      shape.texture = obj.texture;
      shape.sampler = obj.sampler;
      shape.uFogMode = obj.uFogMode;
      shape.uFogColor = obj.uFogColor;
      shape.uFogParms = obj.uFogParms;
      shape.userAttribLocations = obj.userAttribLocations;
      shape.userUniformLocations = obj.userUniformLocations;
      shape.normLoc = obj.normLoc;
      shape.invPrMatLoc = obj.invPrMatLoc;
      shape.clipLoc = obj.clipLoc;
      shape.nextLoc = obj.nextLoc;
      shape.pointLoc = obj.pointLoc;
      shape.aspectLoc = obj.aspectLoc;
      shape.lwdLoc = obj.lwdLoc;
      shape.prog = obj.prog;
      shape.material = obj.material;
      shape.flags = obj.flags;
      shape.defFlags = obj.defFlags;
      shape.someHidden = obj.someHidden;
      shape.fastTransparency = obj.fastTransparency;
      shape.nlights = obj.nlights;
      shape.emission = obj.emission;
      shape.emissionLoc = obj.emissionLoc;
      shape.shininess = obj.shininess;
      shape.shininessLoc = obj.shininessLoc;
      shape.ambient = obj.ambient;
      shape.ambientLoc = obj.ambientLoc;
      shape.specular = obj.specular;
      shape.specularLoc = obj.specularLoc;
      shape.diffuse = obj.diffuse;
      shape.diffuseLoc = obj.diffuseLoc;
      shape.lightDir = obj.lightDir;
      shape.lightDirLoc = obj.lightDirLoc;
      shape.viewpoint = obj.viewpoint;
      shape.viewpointLoc = obj.viewpointLoc;
      shape.finite = obj.finite;
      shape.finiteLoc = obj.finiteLoc;
      shape.prMatLoc = obj.prMatLoc;
      shape.mvMatLoc = obj.mvMatLoc;
      shape.normMatLoc = obj.normMatLoc;
      shape.frontLoc = obj.frontLoc;
      shape.index_uint = false;
      shape.is_transparent = obj.is_transparent;
      shape.ignoreExtent = obj.ignoreExtent;
      if (shape.passes !== obj.passes ||
          JSON.stringify( shape.pmode) !== JSON.stringify(obj.pmode)) {
        shape.passes = obj.passes;
        shape.pmode = obj.pmode;
        for (pass = 0; pass < obj.passes; pass++) {
          mode =  shape.pmode[pass];
          if (typeof  shape.indices[mode] === "undefined") {
            f = [];
            switch (mode) {
            case "culled": break;
            case "points":
              f.length =  shape.vertexCount;
              for (i=0; i < f.length; i++)
                f[i] = i;
              break;
            case "lines":
              if (typeof shape.it !== "undefined") {
                f.length = 2* shape.it.length;
      	        for (i=0; i <  shape.it.length/3; i++) {
      	          f[6*i] =  shape.it[3*i];
      	          f[6*i + 1] =  shape.it[3*i + 1];
      	          f[6*i + 2] =  shape.it[3*i + 1];
      	          f[6*i + 3] =  shape.it[3*i + 2];
      	          f[6*i + 4] =  shape.it[3*i + 2];
      	          f[6*i + 5] =  shape.it[3*i];
      	        }
              } else {
                f.length = 2*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[8*i] = shape.ib[4*i];
                  f[8*i + 1] = shape.ib[4*i + 1];
                  f[8*i + 2] = shape.ib[4*i + 1];
                  f[8*i + 3] = shape.ib[4*i + 2];
                  f[8*i + 4] = shape.ib[4*i + 2];
                  f[8*i + 5] = shape.ib[4*i + 3];
                  f[8*i + 6] = shape.ib[4*i + 3];
                  f[8*i + 7] = shape.ib[4*i];
                }
              }
      	      break;
      	    case "filled":
      	      if (typeof shape.it !== "undefined")
      	        f =  shape.it;
      	      else if (typeof shape.ib !== "undefined") {
      	        f.length = 1.5*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[6*i] = shape.ib[4*i];
                  f[6*i+1] = shape.ib[4*i + 1];
                  f[6*i+2] = shape.ib[4*i + 2];
                  f[6*i+3] = shape.ib[4*i];
                  f[6*i+4] = shape.ib[4*i + 2];
                  f[6*i+5] = shape.ib[4*i + 3];
                }      	        
      	      }
      	      break;
      	    }              
            shape.indices[mode] = new Uint16Array(f);
          }
        }
      }       
      for (pass = 0; pass < obj.passes; pass++) {
        mode =  shape.pmode[pass];
        shape.f[pass] =  shape.indices[mode];
        if (typeof obj.draw_front !== "undefined" &&
            !obj.draw_front) {
          shape.f[pass] = shape.f[pass].filter(is_back);   
        }
      }
      // console.log("Names in  shapes not in  shape:"+JSON.stringify(rglwidgetClass.keydiff(obj,  shape)));
       shape.initialized = true;
    };

    /**
     * Initialize a subscene
     * @param { number } id - id of subscene.
     */
    rglwidgetClass.prototype.initSubscene = function(id) {
      var sub = this.getObj(id),
          i, obj;

      if (sub.type !== "subscene")
        return;

      sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
      sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
      sub.par3d.userProjection.transpose();
      sub.par3d.listeners = [].concat(sub.par3d.listeners);
      sub.backgroundId = undefined;
      sub.subscenes = [];
      sub.clipplanes = [];
      sub.transparent = [];
      sub.opaque = [];
      sub.lights = [];
      sub.needsBegin = true;
      if (typeof sub.objects !== "undefined")
        sub.objects = [].concat(sub.objects); /* make sure it's an array */
      for (i=0; i < sub.objects.length; i++) {
        obj = this.getObj(sub.objects[i]);
        if (typeof obj === "undefined") {
          sub.objects.splice(i, 1);
          i--;
        } else if (obj.type === "background")
          sub.backgroundId = obj.id;
        else
          sub[this.whichList(obj.id)].push(obj.id);
      }
    };
    
    rglwidgetClass.prototype.initBBox = function(obj) {
      if (!this.cube)
        this.initCube();
      obj.cube = {id: obj.id + 0.1,
                    type: "quads",
                    flags: obj.flags,
                    material: obj.material,
                    colors: [obj.colors[0]],
                    vertices: this.cube.vertices,
                    normals: this.cube.normals,
                    draw_front: obj.draw_front,
                    initialized: false
        };
      if (this.getMaterial(obj.cube, "front") !==
          this.getMaterial(obj.cube, "back"))
        /* jshint bitwise: false */  
        obj.cube.flags |= rglwidgetClass.f_is_twosided;
        /* jshint bitwise: true */
      this.scene.objects[obj.cube.id] = obj.cube;
      obj.ticks = {id: obj.id + 0.2,
                     type: "lines",
                     flags: rglwidgetClass.f_has_fog,
                     material: obj.material,
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     axes: obj.axes,
                     initialized: false
      };
      this.scene.objects[obj.ticks.id] = obj.ticks;
      obj.labels = {id: obj.id + 0.3,
                     type: "text",
                     flags: rglwidgetClass.f_has_fog + 
                            rglwidgetClass.f_fixed_size + 
                            rglwidgetClass.f_fixed_quads,
                     material: {lit: false},
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     cex: [[1]],
                     family: [["sans"]],
                     font: [[1]],
                     adj: [[0.5, 0.5, 0.5]],
                     ignoreExtent: true,
                     initialized: false
      };
      this.scene.objects[obj.labels.id] = obj.labels;
      obj.initialized = true;
    };
    
    rglwidgetClass.prototype.initBackground = function(obj) {
      var material, fl = obj.defFlags;
      if (typeof obj.ids !== "undefined")
        obj.quad = rglwidgetClass.flatten([].concat(obj.ids));
      else if (obj.sphere) {
        fl.has_normals = true;
        fl.needs_vnormal = true;
        obj.defFlags = fl;
        material = obj.material;
        material.front = "culled";
        obj.vertices = [[0,0,0]];
        obj.texcoords = [[0,0]];
      }  
    };

    /**
     * Initialize object for display
     * @param { number } id - id of object to initialize
     */
    rglwidgetClass.prototype.initObjId = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("initObj id is "+typeof id);
      }
      return this.initObj(this.getObj(id));
    };

    /**
     * Initialize object for display
     * @param { Object } obj - object to initialize
     */
    rglwidgetClass.prototype.initObj = function(obj) {
      var type = obj.type, 
          flags = obj.flags,
          normals = obj.normals,
          round_points = (typeof obj.material === "undefined") ?
            false : this.getMaterial(obj, "point_antialias"),
          has_indices = typeof obj.indices !== "undefined",
          has_spheres = type === "spheres" || 
                        (type === "background" && obj.sphere),
          sprites_3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          depth_sort = rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort),
          gl = this.gl || this.initGL(),
          fl, polygon_offset,
          texinfo, drawtype, nclipplanes, f, nrows, oldrows,
          i,j,v,v1,v2, mat, uri, matobj, pass, pmode,
          dim, nx, nz, nrow, shaders;

    obj.initialized = true;
    
    obj.someHidden = false; // used in selection
    
    this.expandBufferedFields(obj);
    
    if (type === "subscene")
      return;
      
    obj.defFlags = fl = rglwidgetClass.getDefFlags(flags, type, normals, round_points);
  
    obj.is_transparent = fl.is_transparent;
  
    if (type === "bboxdeco")
      return this.initBBox(obj);
      
    if (has_spheres && typeof this.sphere === "undefined")
      this.initSphere(16, 16);

    if (type === "light") {
      obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
      obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
      obj.specular = new Float32Array(obj.colors[2].slice(0,3));
      obj.lightDir = new Float32Array(obj.vertices[0]);
      return;
    }

    if (type === "clipplanes") {
      obj.vClipplane = rglwidgetClass.flatten(rglwidgetClass.cbind(obj.normals, obj.offsets));
      return;
    }

    if (type === "background") {
      this.initBackground(obj);
      if (!obj.sphere)
        return;
    }

    polygon_offset = this.getMaterial(obj, "polygon_offset");
    if (polygon_offset[0] !== 0 || polygon_offset[1] !== 0)
      obj.polygon_offset = polygon_offset;

    if (fl.is_transparent) {
      depth_sort = ["triangles", "quads", "surface",
                    "spheres", "sprites", "text",
                    "planes"].indexOf(type) >= 0;
    }
    
    if (fl.is_brush)
      this.initSelection(obj.id);

    if (typeof obj.vertices === "undefined")
      obj.vertices = [];

    v = obj.vertices;
    if (has_indices)
      obj.vertexCount = obj.indices.length;
    else
      obj.vertexCount = v.length;
      
    if (!obj.vertexCount) return;

    if (fl.is_twosided && !fl.has_normals && type !== "background") {
      if (typeof obj.userAttributes === "undefined")
        obj.userAttributes = {};
      v1 = Array(v.length);
      v2 = Array(v.length);
      if (obj.type === "triangles" || obj.type === "quads") {
      	if (obj.type === "triangles")
      	  nrow = 3;
      	else
      	  nrow = 4;
        for (i=0; i<Math.floor(v.length/nrow); i++)
          for (j=0; j<nrow; j++) {
            v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
            v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
          }
      } else if (obj.type === "surface") {
        dim = obj.dim[0];
        nx = dim[0];
        nz = dim[1];
        for (j=0; j<nx; j++) {
          for (i=0; i<nz; i++) {
            if (i+1 < nz && j+1 < nx) {
              v2[j + nx*i] = v[j + nx*(i+1)];
              v1[j + nx*i] = v[j+1 + nx*(i+1)];
            } else if (i+1 < nz) {
              v2[j + nx*i] = v[j-1 + nx*i];
              v1[j + nx*i] = v[j + nx*(i+1)];
            } else {
              v2[j + nx*i] = v[j + nx*(i-1)];
              v1[j + nx*i] = v[j-1 + nx*(i-1)];
            }
          }
        }
      }
      obj.userAttributes.aPos1 = v1;
      obj.userAttributes.aPos2 = v2;
    }

    if (!sprites_3d) {
      if (gl.isContextLost()) return;
      if (typeof obj.prog !== "undefined") {
        gl.deleteProgram(obj.prog);
        obj.prog = undefined;
      }
      
      shaders = this.getShaders(obj);
      
      obj.prog = gl.createProgram();
      gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
                      shaders.vertex ));
      gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
                      shaders.fragment ));
      //  Force aPos to location 0, aCol to location 1
      gl.bindAttribLocation(obj.prog, 0, "aPos");
      gl.bindAttribLocation(obj.prog, 1, "aCol");
      gl.linkProgram(obj.prog);
      var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
      if (!linked) {

        // An error occurred while linking
        var lastError = gl.getProgramInfoLog(obj.prog);
        console.warn("Error in program linking:" + lastError);

        gl.deleteProgram(obj.prog);
        return;
      }
    }

    if (type === "text") {
      texinfo = this.drawTextToCanvas(obj.texts,
                                      rglwidgetClass.flatten(obj.cex),
                                      rglwidgetClass.flatten(obj.family),
                                      rglwidgetClass.flatten(obj.family));
    }

    if (fl.fixed_quads && !sprites_3d) {
      obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
    }

    if (fl.has_texture || type === "text") {
      if (!obj.texture) {
        obj.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
      }
      obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
      obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
    }
    
    if (fl.has_fog && !sprites_3d) {
      obj.uFogMode = gl.getUniformLocation(obj.prog, "uFogMode");
      obj.uFogColor = gl.getUniformLocation(obj.prog, "uFogColor");
      obj.uFogParms = gl.getUniformLocation(obj.prog, "uFogParms");
    }

    if (fl.has_texture) {
      mat = obj.material;
      if (typeof mat.uri !== "undefined")
        uri = mat.uri;
      else if (typeof mat.uriElementId === "undefined") {
        matobj = this.getObj(mat.uriId);
        if (typeof matobj !== "undefined") {
          uri = matobj.material.uri;
        } else {
          uri = "";
        }
      } else
        uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;

      this.loadImageToTexture(uri, obj.texture);
    }

    if (type === "text") {
      this.handleLoadedTexture(obj.texture, this.textureCanvas);
    }

    var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
        nextofs = -1, pointofs = -1, alias, colors, key, selection,
        filter, adj, offset, attr, last, options;

    obj.alias = undefined;
    
    colors = obj.colors;

    j = this.scene.crosstalk.id.indexOf(obj.id);
    if (j >= 0) {
      key = this.scene.crosstalk.key[j];
      options = this.scene.crosstalk.options[j];
      colors = colors.slice(0); 
      for (i = 0; i < v.length; i++)
        colors[i] = obj.colors[i % obj.colors.length].slice(0);
      if ( (selection = this.scene.crosstalk.selection) &&
           (selection.length || !options.selectedIgnoreNone) )
        for (i = 0; i < v.length; i++) {
          if (!selection.includes(key[i])) {
            if (options.deselectedColor)
              colors[i] = options.deselectedColor.slice(0);
            colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
          } else if (options.selectedColor)
            colors[i] = options.selectedColor.slice(0);
        }
      if ( (filter = this.scene.crosstalk.filter) )
        for (i = 0; i < v.length; i++) 
          if (!filter.includes(key[i])) {
            if (options.filteredColor)
              colors[i] = options.filteredColor.slice(0);
            colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
          }
    }  
    
    nc = obj.colorCount = colors.length;
    if (nc > 1) {
      cofs = stride;
      stride = stride + 4;
      v = rglwidgetClass.cbind(v, colors);
    } else {
      cofs = -1;
      obj.onecolor = rglwidgetClass.flatten(colors);
    }

    if (fl.has_normals && !has_spheres) {
      nofs = stride;
      stride = stride + 3;
      v = rglwidgetClass.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
    } else
      nofs = -1;

    if (typeof obj.radii !== "undefined") {
      radofs = stride;
      stride = stride + 1;
      // FIXME:  always concat the radii?
      if (obj.radii.length === v.length) {
        v = rglwidgetClass.cbind(v, obj.radii);
      } else if (obj.radii.length === 1) {
        v = v.map(function(row) { return row.concat(obj.radii[0]);});
      }
    } else
      radofs = -1;
      
    // Add default indices
    if (has_indices) {
      f = Array(obj.indices.length);
      for (i = 0; i < f.length; i++)
        f[i] = obj.indices[i] - 1;
    } else {
      f = Array(v.length);
      for (i = 0; i < v.length; i++)
        f[i] = i;
    }
    obj.f = [f,f];

    if (type === "sprites" && !sprites_3d) {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      fnew = new Array(4*v.length);
      alias = new Array(v.length);
      var rescale = fl.fixed_size ? 72 : 1,
          size = obj.radii, s = rescale*size[0]/2;
      last = v.length;
      f = obj.f[0];
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = obj.adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset);
        if (size.length > 1)
          s = rescale*size[i]/2;
        adj[0] = 2*s*(adj[0] - 0.5);
        adj[1] = 2*s*(adj[1] - 0.5);
        adj[2] = 2*s*(adj[2] - 0.5);
        vnew[i]  = v[i].concat([0,0]).concat([-s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i] = f[i];
        vnew[last]= v[i].concat([1,0]).concat([s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i+1] = last++;
        vnew[last]= v[i].concat([1,1]).concat([s-adj[0],
                                               s-adj[1],
                                               -adj[2]]);
        fnew[4*i+2] = last++;
        vnew[last]= v[i].concat([0,1]).concat([-s-adj[0],
                                                s-adj[1],
                                                -adj[2]]);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (type === "text") {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      f = obj.f[0];
      fnew = new Array(4*f.length);
      alias = new Array(v.length);
      last = v.length;
      adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset, obj.texts[i]);
        vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
        fnew[4*i] = f[i];
        vnew[last] = v[i].concat([1,-0.5]).concat(adj);
        fnew[4*i+1] = last++;
        vnew[last] = v[i].concat([1, 1.5]).concat(adj);
        fnew[4*i+2] = last++;
        vnew[last] = v[i].concat([0, 1.5]).concat(adj);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
        for (j=0; j < 4; j++) {
          v1 = vnew[fnew[4*i+j]];
          v1[oofs] = 2*(v1[tofs]-v1[oofs])*texinfo.widths[i];
          v1[oofs+1] = 2*(v1[tofs+1]-v1[oofs+1])*texinfo.textHeights[i];
          v1[oofs+2] = 2*(0.5-v1[oofs+2])*texinfo.textHeights[i]/1000.0;
          v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
          v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
              v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
          vnew[fnew[4*i+j]] = v1;
        }
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (typeof obj.texcoords !== "undefined") {
      tofs = stride;
      stride += 2;
      oofs = -1;
      v = rglwidgetClass.cbind(v, obj.texcoords);
    } else {
      tofs = -1;
      oofs = -1;
    }
    
    obj.alias = alias;
                          
    if (typeof obj.userAttributes !== "undefined") {
      obj.userAttribOffsets = {};
      obj.userAttribLocations = {};
      obj.userAttribSizes = {};
      for (attr in obj.userAttributes) {
      	obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
      	if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
      	  obj.userAttribOffsets[attr] = stride;
      	  v = rglwidgetClass.cbind(v, obj.userAttributes[attr]);
      	  stride = v[0].length;
      	  obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
      	} else
      	  console.warn("attribute '"+attr+"' not found in object "+obj.id+".");
      }
    }

    if (typeof obj.userUniforms !== "undefined" ||
        typeof obj.userTextures !== "undefined") {
      obj.userUniformLocations = {};
      for (attr in obj.userUniforms) {
        obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
        if (obj.userUniformLocations[attr] === null)
          console.warn("uniform '"+attr+"' not found in object "+obj.id+".");
      }
      for (attr in obj.userTextures) {
        var texture = obj.userTextures[attr];
        texture.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
        texture.sampler = gl.getUniformLocation(obj.prog, attr);
        if (texture.sampler === null)
          console.warn("sampler '"+attr+"' not found in object "+obj.id+".");
        uri = texture.uri;
        this.loadImageToTexture(uri, texture.texture);
      }
    }

    if (sprites_3d) {
      obj.userMatrix = new CanvasMatrix4();
      obj.userMatrix.load(rglwidgetClass.flatten(obj.usermatrix));
      obj.objects = rglwidgetClass.flatten([].concat(obj.ids));
      fl.is_lit = false;
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        obj.offset = obj.adj[0];
      } else
        obj.offset = 0;
        
      for (i=0; i < obj.objects.length; i++)
        this.initObjId(obj.objects[i]);
    }

    nclipplanes = this.countClipplanes();
    if (nclipplanes && !sprites_3d) {
      obj.clipLoc = gl.getUniformLocation(obj.prog,"vClipplane");
    }

    if (fl.is_lit) {
      obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
      obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(obj, "emission")));
      obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
      obj.shininess = this.getMaterial(obj, "shininess");
      obj.nlights = this.countLights();
      if (obj.nlights > 0) {
        obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(obj, "ambient")));
        obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(obj, "specular")));
        obj.ambientLoc = gl.getUniformLocation(obj.prog, "ambient");
        obj.specularLoc = gl.getUniformLocation(obj.prog, "specular");
        obj.diffuseLoc = gl.getUniformLocation(obj.prog, "diffuse" );
        obj.lightDirLoc = gl.getUniformLocation(obj.prog, "lightDir");
        obj.viewpointLoc = gl.getUniformLocation(obj.prog, "viewpoint");
        obj.finiteLoc = gl.getUniformLocation(obj.prog, "finite" );
      }
    }
    
    obj.passes = fl.is_twosided + 1;
    obj.pmode = new Array(obj.passes);
    for (pass = 0; pass < obj.passes; pass++) {
      if (type === "triangles" || type === "quads" || type === "surface" || has_spheres)
      	pmode = this.getMaterial(obj, (pass === 0) ? "front" : "back");
      else pmode = "filled";
      obj.pmode[pass] = pmode;
    }
    if (!has_spheres) {
      obj.f.length = obj.passes;
      for (pass = 0; pass < obj.passes; pass++) {
      	f = fnew = obj.f[pass];
        pmode = obj.pmode[pass];
      	if (pmode === "culled")
      	  fnew = [];
        else if (pmode === "points") {
          // stay with default
        } else if ((type === "quads" || type === "text" ||
             type === "sprites") && !sprites_3d) {
          nrows = Math.floor(obj.vertexCount/4);
          if (pmode === "filled") {
            fnew = Array(6*nrows);
            for (i=0; i < nrows; i++) {
              fnew[6*i] = f[4*i];
              fnew[6*i+1] = f[4*i + 1];
              fnew[6*i+2] = f[4*i + 2];
              fnew[6*i+3] = f[4*i];
              fnew[6*i+4] = f[4*i + 2];
              fnew[6*i+5] = f[4*i + 3];
            }
          } else {
            fnew = Array(8*nrows);
            for (i=0; i < nrows; i++) {
              fnew[8*i] = f[4*i];
              fnew[8*i+1] = f[4*i + 1];
              fnew[8*i+2] = f[4*i + 1];
              fnew[8*i+3] = f[4*i + 2];
              fnew[8*i+4] = f[4*i + 2];
              fnew[8*i+5] = f[4*i + 3];
              fnew[8*i+6] = f[4*i + 3];
              fnew[8*i+7] = f[4*i];
            }
          }
        } else if (type === "triangles") {
          nrows = Math.floor(obj.vertexCount/3);
          if (pmode === "filled") {
            fnew = Array(3*nrows);
            for (i=0; i < fnew.length; i++) {
              fnew[i] = f[i];
            }
          } else if (pmode === "lines") {
            fnew = Array(6*nrows);
      	    for (i=0; i < nrows; i++) {
      	      fnew[6*i] = f[3*i];
      	      fnew[6*i + 1] = f[3*i + 1];
      	      fnew[6*i + 2] = f[3*i + 1];
      	      fnew[6*i + 3] = f[3*i + 2];
      	      fnew[6*i + 4] = f[3*i + 2];
      	      fnew[6*i + 5] = f[3*i];
      	    }
          }
        } else if (has_spheres) {
          // default
        } else if (type === "surface") {
          dim = obj.dim[0];
          nx = dim[0];
          nz = dim[1];
          if (pmode === "filled") {
            fnew = [];
            for (j=0; j<nx-1; j++) {
              for (i=0; i<nz-1; i++) {
                fnew.push(f[j + nx*i],
                       f[j + nx*(i+1)],
                       f[j + 1 + nx*(i+1)],
                       f[j + nx*i],
                       f[j + 1 + nx*(i+1)],
                       f[j + 1 + nx*i]);
              }
            }
          } else if (pmode === "lines") {
            fnew = [];
            for (j=0; j<nx; j++) {
              for (i=0; i<nz; i++) {
                if (i+1 < nz)
                  fnew.push(f[j + nx*i],
                         f[j + nx*(i+1)]);
                if (j+1 < nx)
                  fnew.push(f[j + nx*i],
                         f[j+1 + nx*i]);
              }
            }
          }
        }
        obj.f[pass] = fnew;
        if (depth_sort) {
          drawtype = "DYNAMIC_DRAW";
        } else {
          drawtype = "STATIC_DRAW";
        }
      }
    }
    
    if (fl.fat_lines) {
      alias = undefined;
      obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
      obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
      obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
      obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
      // Expand vertices to turn each segment into a pair of triangles
        
      	for (pass = 0; pass < obj.passes; pass++) {
      	  f = obj.f[pass];	
          oldrows = f.length;
      	  if (obj.pmode[pass] === "lines") 
      	    break;
      	}
      
      if (type === "linestrip") 
        nrows = 4*(oldrows - 1); 
      else
        nrows = 2*oldrows;
      vnew = new Array(nrows);
      fnew = new Array(1.5*nrows);
      
      // We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
      // added.
      // We do this by copying the originals in the first pass, adding the new attributes, then in a 
      // second pass add new vertices at the end.

      for (i = 0; i < v.length; i++) {
        vnew[i] = v[i].concat([0,0,0,0,0]); 
      }

      nextofs = stride;
      pointofs = stride + 3;
      stride = stride + 5;
            
      // Now add the extras
      var ind, k;
      last = v.length - 1;
      ind = 0;
      alias = new Array(f.length);
      for (i = 0; i < f.length; i++)
        alias[i] = [];
      for (i = 0; i < f.length - 1; i++) {
      	if (type !== "linestrip" && i % 2 === 1)
      	  continue;
      	k = ++last;
      	vnew[k] = vnew[f[i]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i+1]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = -1;
      	fnew[ind] = k;
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+1] = last;
      	alias[f[i]].push(last-1, last);
      	last++;
      	k = last;
      	vnew[k] = vnew[f[i+1]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = 1;
      	fnew[ind+2] = k;
      	fnew[ind+3] = fnew[ind+1];
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+4] = last;
      	fnew[ind+5] = fnew[ind+2];
      	ind += 6;
      	alias[f[i+1]].push(last-1, last);
      }
      vnew.length = last+1;
      v = vnew;
      obj.vertexCount = v.length;
      if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
        var oldalias = obj.alias, newalias = Array(obj.alias.length);
        for (i = 0; i < newalias.length; i++) {
          newalias[i] = oldalias[i].slice();
          for (j = 0; j < oldalias[i].length; j++)
            Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
        }
        obj.alias = newalias;
      } else
        obj.alias = alias;
      
      for (pass = 0; pass < obj.passes; pass++)
      	if (type === "lines" || type === "linestrip" || obj.pmode[pass] === "lines") {
          obj.f[pass] = fnew;
        }
      
      if (depth_sort) 
        drawtype = "DYNAMIC_DRAW";
      else
        drawtype = "STATIC_DRAW";
    }
    
      for (pass = 0; pass < obj.passes; pass++) {
        if (obj.vertexCount > 65535) {
          if (this.index_uint) {
            obj.f[pass] = new Uint32Array(obj.f[pass]);
            obj.index_uint = true;
          } else
            this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
        } else {
          obj.f[pass] = new Uint16Array(obj.f[pass]);
          obj.index_uint = false;
        }
      }
    
    if (stride !== v[0].length) {
      this.alertOnce("problem in stride calculation");
    }

    obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
                    nextofs:nextofs, pointofs:pointofs, stride:stride};

    obj.values = new Float32Array(rglwidgetClass.flatten(v));

    if (!has_spheres && !sprites_3d) {
      obj.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
      gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
      obj.ibuf = Array(obj.passes);
      obj.ibuf[0] = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
      if (fl.is_twosided) {
      	obj.ibuf[1] = gl.createBuffer();
      	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
      	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
      }
    }

    if (!sprites_3d) {
      obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
      obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");

      if (fl.fixed_size) {
        obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
      }
    }

    if (fl.needs_vnormal) {
      obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
      obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
    }

    if (fl.is_twosided) {
      obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
      if (fl.has_normals)
        obj.invPrMatLoc = gl.getUniformLocation(obj.prog, "invPrMatrix");
    }
  };
    
    /**
     * Initialize the DOM object
     * @param { Object } el - the DOM object
     * @param { Object } x - the scene data sent by JSON from R
     */
    rglwidgetClass.prototype.initialize = function(el, x) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.style.display = "block";
      this.scene = x;
      this.normMatrix = new CanvasMatrix4();
      this.invPrMatrix = new CanvasMatrix4();
      this.saveMat = {};
      this.distance = null;
      this.posLoc = 0;
      this.colLoc = 1;
      if (el) {
        el.rglinstance = this;
        this.el = el;
        this.webGLoptions = el.rglinstance.scene.webGLoptions;
        this.initCanvas();
      }
      if (typeof Shiny !== "undefined") {
        var self = this;
        Shiny.addCustomMessageHandler("shinyGetPar3d",
          function(message) {
            var i, param, 
                subscene = self.getObj(message.subscene),
                parameters = [].concat(message.parameters),
                result = {tag: message.tag, subscene: message.subscene};
            if (typeof subscene !== "undefined") {
              for (i = 0; i < parameters.length; i++) {
                param = parameters[i];
                result[param] = subscene.par3d[param];
              }
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
            Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
          });
          
        Shiny.addCustomMessageHandler("shinySetPar3d",
          function(message) {
            var param = message.parameter, 
                subscene = self.getObj(message.subscene);
            if (typeof subscene !== "undefined") {
              subscene.par3d[param] = message.value;
              subscene.initialized = false;
              self.drawScene();
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
          });
          
        Shiny.addCustomMessageHandler("resetBrush",
          function(message) {
            if (message === self.scene.selectionInput) {
              self.clearBrush(null);
              self.recordSelection(0);
            }
          });
      }
    };
    
    /**
     * Restart the WebGL canvas
     */
    rglwidgetClass.prototype.restartCanvas = function() {
      var newcanvas = document.createElement("canvas"),
          self = this, 
          labelid = this.el.getAttribute("aria-labelledby");
      newcanvas.width = this.el.width;
      newcanvas.height = this.el.height;
      newcanvas.setAttribute("aria-labelledby", 
        labelid);
        
      if (typeof this.scene.altText !== "undefined")
        // We're in Shiny, so alter the label
        document.getElementById(labelid).innerHTML = this.scene.altText;

      newcanvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      newcanvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      while (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }
      this.el.appendChild(newcanvas);
      this.canvas = newcanvas;
      if (this.scene.javascript) {
        /* jshint evil:true */
        Function('"use strict";' + this.scene.javascript)();
        /* jshint evil:false */
      }
      this.setMouseHandlers();
      if (this.gl) 
        Object.keys(this.scene.objects).forEach(function(key){
          self.getObj(parseInt(key, 10)).texture = undefined; 
          });
      this.gl = null;
    };

    /**
     * Initialize the WebGL canvas
     */
    rglwidgetClass.prototype.initCanvas = function() {
      this.restartCanvas();
      var objs = this.scene.objects,
          self = this;
          
      /* These hold context specific data.  In Shiny, they   
         need to be deleted.  Elsewhere, they don't exist
         and these are no-ops. */
         
      delete this.cube;
      delete this.sphere;
      
      Object.keys(objs).forEach(function(key){
        self.initSubscene(parseInt(key, 10));
      });

      this.onContextRestored = function() {
        self.initGL();
        self.drawScene();
      };

      this.onContextLost = function(event) {
        if (!self.drawing)
          this.gl = null;
        event.preventDefault();
      };

      this.initGL0();
      this.lazyLoadScene = function() {
      	if (typeof self.slide === "undefined")
      	  self.slide = self.getSlide();
      	if (self.isInBrowserViewport()) {
      	  if (!self.gl || self.gl.isContextLost())
      	    self.initGL();
      	  self.drawScene();
      	}
      };
      window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
      window.addEventListener("load", this.lazyLoadScene, false);
      window.addEventListener("resize", this.lazyLoadScene, false);
      window.addEventListener("scroll", this.lazyLoadScene, false);
      this.slide = this.getSlide();
      if (this.slide) {
        if (typeof this.slide.rgl === "undefined")
          this.slide.rgl = [this];
        else
          this.slide.rgl.push(this);
        if (this.scene.context.rmarkdown) 
          if (this.scene.context.rmarkdown === "ioslides_presentation") {
            this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
          } else if (this.scene.context.rmarkdown === "slidy_presentation") {
            // This method would also work in ioslides, but it gets triggered
            // something like 5 times per slide for every slide change, so
            // you'd need a quicker function than lazyLoadScene.
            var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
            observer = new MutationObserver(function(mutations) {
              mutations.forEach(function() {
                self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
            observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
          }
      }
    };
</script>
<script>/**
 * Methods related to drawing transparent objects
 * @name ___METHODS_FOR_TRANSPARENCY___
 * @memberof rglwidgetClass
 * @kind function
 * @instance

 * These functions order the centers of displayed objects so they
 * can be drawn using the painters algorithm, necessary to support
 * transparency.  

 * Note that objid is not obj.id when drawing spheres.
 */

/**
 * Break objects into pieces
 * @returns { array } Array of pieces
 */
    rglwidgetClass.prototype.getPieces = function(context, objid, subid, obj) {
      var n = obj.centers.length,
          depth,
          result = new Array(n),
          z, w, i;
      context = context.slice();
          
      for(i=0; i<n; i++) {
        z = this.prmvMatrix.m13*obj.centers[i][0] +
            this.prmvMatrix.m23*obj.centers[i][1] +
            this.prmvMatrix.m33*obj.centers[i][2] +
            this.prmvMatrix.m43;
        w = this.prmvMatrix.m14*obj.centers[i][0] +
            this.prmvMatrix.m24*obj.centers[i][1] +
            this.prmvMatrix.m34*obj.centers[i][2] +
            this.prmvMatrix.m44;
        depth = z/w;
        result[i] = {context: context, 
                     objid: objid,
                     subid: subid,
                     index: i, 
                     depth: depth};
      }
      return result;    
    };
    
    /**
     * Get pieces from sphere
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getSpherePieces = function(context, subid, obj)
    {
      if (obj.fastTransparency) 
        if (subid === 0) // Only compute pieces once
          return this.getPieces(context, obj.id, -1, obj);
        else
          return [];
      else
        return this.getPieces(context, obj.id, subid, this.sphere);
    };
    
   /**
     * Get pieces from cube
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getCubePieces = function(context, obj)
    {
      return this.getPieces(context, obj.id, 0, this.cube);
    };
    
    /**
     * Merge pieces that can be drawn in one call
     * @returns { object }
     * @param { array } pieces - The pieces to merge
     */
    rglwidgetClass.prototype.mergePieces = function(pieces) {
      var result = [];
      if (pieces.length > 0) {
        var i,
          thiscontext = pieces[0].context, 
          thisobjid = pieces[0].objid, 
          thissubid = pieces[0].subid,
          indices = [];
        for (i= 0; i < pieces.length; i++) {
          if (pieces[i].context !== thiscontext || 
              pieces[i].objid !== thisobjid ||
              pieces[i].subid !== thissubid) {
            result.push({context: thiscontext, objid: thisobjid,
                         subid: thissubid, indices: indices});
            thiscontext = pieces[i].context;
            thisobjid = pieces[i].objid;
            thissubid = pieces[i].subid;
            indices = [];
          }
          indices.push(pieces[i].index);
        }
        result.push({context: thiscontext, objid: thisobjid,
                                subid: thissubid,
                                indices: indices});
      }
      return result;
    };

    /**
     * Sort pieces by depth
     * @returns { array }
     * @param { array } pieces - array of pieces 
     */
    rglwidgetClass.prototype.sortPieces = function(pieces) {
      var compare = function(i,j) {
        var diff = j.depth - i.depth;
        // We want to avoid context or obj changes,
        // so sort on those next.
        if (diff === 0) {
          var c1 = j.context.slice(),
              c2 = i.context.slice();
          diff = c1.length - c2.length; 
          while (diff === 0 && c1.length > 0) {
            diff = c1.pop() - c2.pop();
          }
          if (diff === 0)
            diff = j.objid - i.objid;
          if (diff === 0)
            diff = j.subid - i.subid;
        }
        return diff;
      }, result = [];
      if (pieces.length) 
        result = pieces.sort(compare);
      return result;
    };
</script>
<script>    /**
     * Methods related to drawing
     * @name ___METHODS_FOR_DRAWING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start drawing
     * @returns { boolean } Previous state
     */
    rglwidgetClass.prototype.startDrawing = function() {
    	var value = this.drawing;
    	this.drawing = true;
    	return value;
    };

    /**
     * Stop drawing and check for context loss
     * @param { boolean } saved - Previous state
     */
    rglwidgetClass.prototype.stopDrawing = function(saved) {
      this.drawing = saved;
      if (!saved && this.gl && this.gl.isContextLost())
        this.restartCanvas();
    };

    /**
     * Update the triangles used to display a plane
     * @param { number } id - id of the plane
     * @param { Object } bbox - bounding box in which to display the plane
     */
    rglwidgetClass.prototype.planeUpdateTriangles = function(obj, bbox) {
      var perms = [[0,0,1], [1,2,2], [2,1,0]],
          x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
          face1 = [], face2 = [], normals = [],
          nPlanes = obj.normals.length, idx, center;
      obj.bbox = bbox;
      obj.vertices = [];
      obj.centers = [];
      obj.initialized = false;
      for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
        x = [];
        A = obj.normals[elem];
        d = obj.offsets[elem][0];
        nhits = 0;
        for (i=0; i<3; i++)
          for (j=0; j<2; j++)
            for (k=0; k<2; k++) {
              u = perms[0][i];
              v = perms[1][i];
              w = perms[2][i];
              if (A[w] !== 0.0) {
                intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
                if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
                  xrow = [];
                  xrow[u] = bbox[j+2*u];
                  xrow[v] = bbox[k+2*v];
                  xrow[w] = intersect;
                  x.push(xrow);
                  face1[nhits] = j + 2*u;
                  face2[nhits] = k + 2*v;
                  nhits++;
                }
              }
            }

            if (nhits > 3) {
            /* Re-order the intersections so the triangles work */
              for (i=0; i<nhits-2; i++) {
                which = 0; /* initialize to suppress warning */
                for (j=i+1; j<nhits; j++) {
                  if (face1[i] === face1[j] || face1[i] === face2[j] ||
                      face2[i] === face1[j] || face2[i] === face2[j] ) {
                    which = j;
                    break;
                  }
                }
                if (which > i+1) {
                  rglwidgetClass.swap(x, i+1, which);
                  rglwidgetClass.swap(face1, i+1, which);
                  rglwidgetClass.swap(face2, i+1, which);
                }
              }
            }
            if (nhits >= 3) {
      /* Put in order so that the normal points out the FRONT of the faces */
              v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
              v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
              /* cross-product */
              vx = rglwidgetClass.xprod(v0, v2);
              reverse = rglwidgetClass.dotprod(vx, A) > 0;

              for (i=0; i<nhits-2; i++) {
                obj.vertices.push(x[0]);
                center = [];
                for (k = 0; k<3; k++)
                  center.push(x[0][k]/3);
                normals.push(A);
                for (j=1; j<3; j++) {
                  idx = i + (reverse ? 3-j : j);
                  obj.vertices.push(x[idx]);
                  for (k=0; k<3; k++)
                    center[k] += x[idx][k]/3;
                  normals.push(A);
                }
                obj.centers.push(center);
              }
            }
      }
      obj.pnormals = normals;
    };
    
    rglwidgetClass.prototype.mode4type = {points : "POINTS",
                     linestrip : "LINE_STRIP",
                     abclines : "LINES",
                     lines : "LINES",
                     sprites : "TRIANGLES",
                     planes : "TRIANGLES",
                     text : "TRIANGLES",
                     quads : "TRIANGLES",
                     surface : "TRIANGLES",
                     triangles : "TRIANGLES",
                     sphere : "TRIANGLES"
    };
    
    /**
     * Disable unused arrays
     * @param { Object } obj - Object to work with
     * @param { Array } enabled - Array indicating which are enabled
     */
    rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
      var gl = this.gl || this.initGL(),
          objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
          thisLocs = ["posLoc", "colLoc"], i, attr;
      for (i = 0; i < objLocs.length; i++) 
        if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
      for (i = 0; i < thisLocs.length; i++)
        if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
      if (typeof obj.userAttributes !== "undefined") {
      	for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
      	}
      }
    };

    /**
     * Start drawing the scene
     */    
    rglwidgetClass.prototype.doStartScene = function() {
      var gl = this.gl || this.initGL();
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1,1,1,1);
      gl.depthMask(true); // Must be true before clearing depth buffer
      /* jshint bitwise: false */
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      /* jshint bitwise: true */
    };
    
    /**
     * Set gl depth test based on object's material
     * @param { Object } obj - object to use
     */
    rglwidgetClass.prototype.doDepthTest = function(obj) {
      var gl = this.gl,
          tests = {never: gl.NEVER,
                   less:  gl.LESS,
                   equal: gl.EQUAL,
                   lequal:gl.LEQUAL,
                   greater: gl.GREATER,
                   notequal: gl.NOTEQUAL,
                   gequal: gl.GEQUAL,
                   always: gl.ALWAYS},
           test = tests[this.getMaterial(obj, "depth_test")];
      gl.depthFunc(test);
    };    
    
    /**
     * Set polygon offset for an obj
     * @param { object } obj - object to use
     */
    rglwidgetClass.prototype.doPolygonOffset = function(obj) { 
      var gl = this.gl;
      if (typeof obj.polygon_offset !== "undefined") {
        gl.polygonOffset(obj.polygon_offset[0],
                          obj.polygon_offset[1]);
        gl.enable(gl.POLYGON_OFFSET_FILL);
      } else
        gl.disable(gl.POLYGON_OFFSET_FILL);
    };
    
    /**
     * Do code for clipping
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doClipping = function(obj, subscene) {
      var gl = this.gl,
          clipcheck = 0,
          clipplaneids = subscene.clipplanes,
          clip, i,j, n = this.countClipplanes(),
          clipplanedata; 
          
      if (n > 0) {
        clipplanedata = new Float32Array(4*n);
        for (i=0; i < clipplaneids.length; i++) {
          clip = this.getObj(clipplaneids[i]);
          for (j=0; j < clip.offsets.length; j++) {
            clipplanedata.set(clip.IMVClip[j], clipcheck);
            clipcheck += 4;
          }
        }
      
        // Leftovers are initialized to zero, which is fine
        gl.uniform4fv(obj.clipLoc, clipplanedata);
      }
    };
    
    /**
     * Do code for lighting
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doLighting = function(obj, subscene) {
    var gl = this.gl, i, j, n, light,
      ambient, specular, diffuse, lightDir, viewpoint, finite,
      ambient0, specular0;

      gl.uniform3fv( obj.emissionLoc, obj.emission);
      gl.uniform1f( obj.shininessLoc, obj.shininess);
      while ((typeof subscene.lights === "undefined" ||
              subscene.lights.length === 0) && 
             typeof subscene.parent !== "undefined")
        subscene = this.getObj(subscene.parent);

      if (typeof subscene.lights === "undefined")
        return;
        
      n = subscene.lights.length;
        
      ambient = new Float32Array(3*n);
      specular = new Float32Array(3*n);
      diffuse = new Float32Array(3*n);
      lightDir = new Float32Array(3*n);
      viewpoint = new Int32Array(n);
      finite = new Int32Array(n);
          
      for (i=0; i < n; i++) {
        light = this.getObj(subscene.lights[i]);
        if (!light.initialized) this.initObj(light);
        ambient0 = this.componentProduct(light.ambient, obj.ambient);
        specular0 = this.componentProduct(light.specular, obj.specular);
        for (j=0; j < 3; j++) {
          ambient[3*i + j] = ambient0[j];
          specular[3*i + j] = specular0[j];
          diffuse[3*i + j] = light.diffuse[j];
          lightDir[3*i + j] = light.lightDir[j];
        }
        viewpoint[i] = light.viewpoint;
        finite[i] = light.finite;
      }
        
      for (i = n; i < obj.nlights; i++) {
        for (j = 0; j < 3; j++) {
          ambient[3*i + j] = 0.0;
          specular[3*i + j] = 0.0;
          diffuse[3*i + j] = 0.0;
        }
      }
        
      gl.uniform3fv( obj.ambientLoc, ambient);
      gl.uniform3fv( obj.specularLoc, specular);
      gl.uniform3fv( obj.diffuseLoc, diffuse);
      gl.uniform3fv( obj.lightDirLoc, lightDir);
      gl.uniform1iv( obj.viewpointLoc, viewpoint);
      gl.uniform1iv( obj.finiteLoc, finite);
    };
    
    /**
     * Do code for colors
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doColors = function(obj) {
      var gl = this.gl;
      if (obj.colorCount === 1) {
        gl.disableVertexAttribArray( this.colLoc );
        gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
        return false;
      } else {
        gl.enableVertexAttribArray( this.colLoc );
        gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
        return true;
      }
    };
    
    /**
     * Do code for normals
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormals = function(obj) {
      var gl = this.gl;
      if (obj.vOffsets.nofs >= 0) {
        gl.enableVertexAttribArray( obj.normLoc );
        gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
        return true;
      } else
        return false;
    };
    
    /**
     * Do code for vNormal
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormMat = function(obj) {
      var gl = this.gl;
        
      gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
    };
    
    /**
     * Do code for textures
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doTexture = function(obj) {
      var gl = this.gl, 
          is_sphere = obj.type === "sphere";
        gl.enableVertexAttribArray( obj.texLoc );
        if (is_sphere)
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride, 4*this.sphere.vOffsets.tofs);
        else
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.uniform1i( obj.sampler, 0);
        return true;
    };
    
    /**
     * Do code for user attributes
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserAttributes = function(obj) {
      if (typeof obj.userAttributes !== "undefined") {
        var gl = this.gl;
      	for (var attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
      	  gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
      	  			  gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
      	}
      }
    };

    /**
     * Do code for user uniforms
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserUniforms = function(obj) {
      var gl = this.gl, attr;
      if (typeof obj.userUniforms !== "undefined") {
      	for (attr in obj.userUniformLocations) {
      	  var loc = obj.userUniformLocations[attr];
      	  if (loc !== null) {
      	    var uniform = obj.userUniforms[attr];
      	    if (typeof uniform !== "undefined") {
      	      var dim = rglwidgetClass.arrayDim(uniform);
      	      if (dim.length === 0)
      	        gl.uniform1f(loc, uniform);
      	      else if (dim.length === 1) {
      	        uniform = new Float32Array(uniform);
      	        switch(uniform.length) {
      	      	  case 2: gl.uniform2fv(loc, uniform); break;
      	      	  case 3: gl.uniform3fv(loc, uniform); break;
      	      	  case 4: gl.uniform4fv(loc, uniform); break;
      	      	  default: console.warn("bad uniform length");
      	        }
      	      } else if (dim.length === 2 && dim[0] === 4 && dim[1] === 4)
      	        gl.uniformMatrix4fv(loc, false, new Float32Array(rglwidgetClass.flatten(uniform)));
      	      else if (dim.length === 2) {
      	        uniform = new Float32Array(rglwidgetClass.flatten(uniform));
      	        switch(dim[[1]]) {
      	          case 1: gl.uniform1fv(loc, uniform); break;
      	          case 2: gl.uniform2fv(loc, uniform); break;
      	          case 3: gl.uniform3fv(loc, uniform); break;
      	          case 4: gl.uniform4fv(loc, uniform); break;
      	          default: console.warn("bad uniform column count");
      	        }
      	      } else
      	        console.warn("unsupported uniform shape");
      	    }
      	  }
      	}
      }
      if (typeof obj.userTextures !== "undefined") {
        var has_texture = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_has_texture),
              texnum = has_texture - 1;
        for (attr in obj.userTextures) {
      	  var texture = obj.userTextures[attr];
      	  if (texture.sampler !== null) {
      	    texnum += 1;
      	    gl.activeTexture(gl.TEXTURE0 + texnum);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            gl.uniform1i( texture.sampler, texnum);
      	  }
      	}
      }
    };

    /**
     * Load indices for complex drawing
     * @param { object } obj - Object to work with
     * @param { numeric } pass - Which pass of drawing?
     * @param { array } indices - Indices to draw
     */    
    rglwidgetClass.prototype.doLoadIndices = function(obj, pass, indices) {
      var gl = this.gl,
          f = obj.f[pass],
          type = obj.type,
          fat_lines = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_fat_lines),
          fnew, step;
      switch(type){
        case "points":
          step = 1;
          break;
        case "abclines":
        case "lines":
          if (fat_lines)
            step = 6;
          else
            step = 2;
          break;
        case "linestrip":
          if (fat_lines)
            step = 6;
          else
            step = 1;
          break;
        case "sphere":
        case "planes":
        case "triangles":
          step = 3;
          break;
        case "text":
        case "sprites":
        case "quads":
        case "surface":
          step = 6;
          break;
        default:
          console.error("loadIndices for "+type);
          return 0;
      }
      if (obj.index_uint)
        fnew = new Uint32Array(step * indices.length);
      else
        fnew = new Uint16Array(step * indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < step; j++) {
          fnew[step*i + j] = f[step*indices[i] + j];
        }
      }
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fnew, gl.DYNAMIC_DRAW);
      return fnew.length;
    };

    /**
     * Do code for depth masking
     * @param { boolean } mask - whether to mask
     */
    rglwidgetClass.prototype.doMasking = function(mask) {
      var gl = this.gl;
      gl.depthMask(mask);
    };

    /**
     * Do code for alpha blending
     * @param { boolean }  blend - Whether to blend.
     * @param { integer }  objid - Object id
     */    
    rglwidgetClass.prototype.doBlending = function(blend, objid) {
      var gl = this.gl, blendfunc, obj, 
        blends =  {zero: gl.ZERO,
                   one:  gl.ONE,
                   src_color: gl.SRC_COLOR,
                   one_minus_src_color: gl.ONE_MINUS_SRC_COLOR,
                   dst_color: gl.DST_COLOR,
                   one_minus_dst_color: gl.ONE_MINUS_DST_COLOR,
                   src_alpha: gl.SRC_ALPHA,
                   one_minus_src_alpha: gl.ONE_MINUS_SRC_ALPHA,
                   dst_alpha: gl.DST_ALPHA,
                   one_minus_dst_alpha: gl.ONE_MINUS_DST_ALPHA,
                   constant_color: gl.CONSTANT_COLOR,
                   one_minus_constant_color: gl.ONE_MINUS_CONSTANT_COLOR,
                   constant_alpha: gl.CONSTANT_ALPHA,
                   one_minus_constant_alpha: gl.ONE_MINUS_CONSTANT_ALPHA,
                   src_alpha_saturate: gl.SRC_ALPHA_SATURATE};
      if (blend) {
        obj = this.getObj(objid);
        blendfunc = this.getMaterial(obj, "blend");
        gl.blendFuncSeparate(blends[blendfunc[0]],
                             blends[blendfunc[1]],
                             gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
    };
    
    /**
     * Set up for fog in the subscene
     * @param { object } obj - background object
     * @param { object } subscene - which subscene
     */
    rglwidgetClass.prototype.doFog = function(obj, subscene) {
      var gl = this.gl, fogmode, color, 
          observer = subscene.par3d.observer[2],
          sintheta = Math.sin(subscene.par3d.FOV*Math.PI/180/2),
          parms = [this.frustum.near - 2*observer,
                   this.frustum.far - 2*observer,
                   this.fogScale,
                   (1-sintheta)/(1+sintheta)];
      if (typeof this.fogType === "undefined")
        this.fogType = "none";
      if (typeof this.fogScale === "undefined")
        parms[2] = 1;
      if (sintheta === 0)
        parms[3] = 1/3;
      switch(this.fogType){
        case "none": fogmode = 0; break;
        case "linear": 
          fogmode = 1; break;
        case "exp":  
          fogmode = 2; break;
        case "exp2": 
          fogmode = 3;
          break;
        default: console.error("Unknown fogtype "+this.fogType);
      }
      gl.uniform1i(obj.uFogMode, fogmode);
      color = this.fogColor;
      gl.uniform3f(obj.uFogColor, color[0], color[1], color[2]);
      gl.uniform4f(obj.uFogParms, parms[0], parms[1], parms[2], parms[3]);
    };

    /* The draw methods are called twice.  When 
       this.opaquePass is true, they should draw opaque parts
       of the scene, and return the list of transparent
       pieces.  Here context is the context array on input,
       modified when the matrices are changed.
       When this.opaquePass is false, the context argument
       contains a "piece", i.e. an ordered list of parts
       of the object to draw. */

    /**
     * Draw simple object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */       
    rglwidgetClass.prototype.drawSimple = function(obj, subscene, context) {
      var 
          fl,
          is_transparent,
          type = obj.type,
          gl = this.gl || this.initGL(),
          count,
          pass, mode, pmode,
          enabled = {};
        
      if (!obj.initialized)
        this.initObj(obj);
        
      if (this.texturesLoading)
        return[];

      count = obj.vertexCount;
      if (!count)
        return [];
    
      fl = obj.defFlags;
      is_transparent = fl.is_transparent || obj.someHidden;
      
      if (is_transparent && this.opaquePass)
        return this.getPieces(context, obj.id, 0, obj);

      this.doDepthTest(obj);
      
      this.doMasking(this.getMaterial(obj, "depth_mask"));
            
      gl.useProgram(obj.prog);

      this.doPolygonOffset(obj);

      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);

      gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
      gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );

      this.doClipping(obj, subscene);

      if (fl.needs_vnormal)
        this.doNormMat(obj);
        
      if (fl.is_lit)
        this.doLighting(obj, subscene);

      if (fl.has_fog)
        this.doFog(obj, subscene);

      this.doUserAttributes(obj);

      this.doUserUniforms(obj);
 
      gl.enableVertexAttribArray( this.posLoc );
      enabled.posLoc = true;
        
      if (fl.has_texture || obj.type === "text")
        enabled.texLoc = this.doTexture(obj);

      enabled.colLoc = this.doColors(obj);
      enabled.normLoc = this.doNormals(obj);

      if (fl.fixed_size) {
        gl.uniform3f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height, 1.0);
      }
      
      if (fl.fixed_quads) {
        gl.enableVertexAttribArray( obj.ofsLoc );
        enabled.ofsLoc = true;
        gl.vertexAttribPointer(obj.ofsLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
      }

      for (pass = 0; pass < obj.passes; pass++) {
      	pmode = obj.pmode[pass];
        if (pmode === "culled")
          continue;

      	mode = fl.fat_lines && (fl.is_lines || pmode === "lines") ? "TRIANGLES" : this.mode4type[type];

      	if (fl.is_twosided) {
      	  gl.uniform1i(obj.frontLoc, pass !== 0);
      	  if (fl.has_normals) {
      	    gl.uniformMatrix4fv(obj.invPrMatLoc, false, new Float32Array(this.invPrMatrix.getAsArray()));
      	  }
      	}

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
        if (!this.opaquePass) {
          if (type === "sphere" && obj.fastTransparency)
            count = this.doLoadIndices(obj, pass, this.sphere.fastpieces[0].indices);
          else
            count = this.doLoadIndices(obj, pass, context.indices);
        } else {
          count = obj.f[pass].length;
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[pass], gl.STATIC_DRAW);
        }
      	if (!fl.is_lines && pmode === "lines" && !fl.fat_lines) {
          mode = "LINES";
        } else if (pmode === "points") {
          mode = "POINTS";
        }
                          
        if ((fl.is_lines || pmode === "lines") && fl.fat_lines) {
          gl.enableVertexAttribArray(obj.pointLoc);
          enabled.pointLoc = true;
          gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
          gl.enableVertexAttribArray(obj.nextLoc );
          enabled.nextLoc = true;
          gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
          gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
          gl.uniform1f(obj.lwdLoc, this.getMaterial(obj, "lwd")/this.vp.height);
        }

        gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);

        gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
      }
      this.disableArrays(obj, enabled);
      return [];
    };

    /**
     * Draw planes object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */      
    rglwidgetClass.prototype.drawPlanes = function(obj, subscene, context) {
      if (this.opaquePass && (obj.bbox !== subscene.par3d.bbox || !obj.initialized)) {
          this.planeUpdateTriangles(obj, subscene.par3d.bbox);
      }
      return this.drawSimple(obj, subscene, context);
   };

    /**
     * @param { object } obj - object to draw
     * @param { object } subscene 
     * @param { array } context 
     * @description
     * Draw spheres in a subscene<br>
     * 
     * Drawing spheres happens in six ways:<br>
     * 1 opaquepass, not transparent:  transform and draw this.sphere count times<br>
     * 2 opaquepass, transparent, not fast: transform & collect sphere pieces count times<br>
     * 3 opaquepass, transparent, fast:  order the centres into separate pieces, order this.sphere once<br>
     * 4 not opaquepass, not transparent:  do nothing<br>
     * 5 not opaquepass, transparent, not fast:  transform for one sphere, draw one merged piece<br>
     * 6 not opaquepass, transparent, fast:  transform for one sphere, draw this.sphere in fixed order.<br>
     **/

    rglwidgetClass.prototype.drawSpheres = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sphereMV, baseofs, ofs, sscale, i,
          count, nc, scount, scale, indices, sphereNorm,
          enabled = {}, drawing,
          saveNorm = new CanvasMatrix4(this.normMatrix),
          saveMV = new CanvasMatrix4(this.mvMatrix),
          savePRMV = null,
          result = [], idx, margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!obj.initialized)
        this.initObj(obj);

      count = obj.vertexCount;
      if (!count) 
        return [];
        
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return [];
        
      if (this.prmvMatrix !== null)
        savePRMV = new CanvasMatrix4(this.prmvMatrix);
      
      scale = subscene.par3d.scale;        
      sphereNorm = new CanvasMatrix4();
      sphereNorm.scale(scale[0], scale[1], scale[2]);
      sphereNorm.multRight(saveNorm);
      this.normMatrix = sphereNorm;

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      if (drawing) {
        nc = obj.colorCount;
        if (nc === 1) {
          this.sphere.onecolor = obj.onecolor;
        }
      }
      
      this.initShapeFromObj(this.sphere, obj);

      if (!this.opaquePass && obj.fastTransparency && typeof this.sphere.fastpieces === "undefined") {
        this.sphere.fastpieces = this.getPieces(context.context, obj.id, 0, this.sphere);
        this.sphere.fastpieces = this.sortPieces(this.sphere.fastpieces);
        this.sphere.fastpieces = this.mergePieces(this.sphere.fastpieces);
      }

      if (this.opaquePass)
        scount = count;
      else {
        indices = context.indices;
        if (obj.fastTransparency)
          scount = indices.length;  /* Each item gives the center of a whole sphere */
        else
          scount = 1;               /* Each item is a fragment of the sphere, at location subid */
      }
      for (i = 0; i < scount; i++) {
        sphereMV = new CanvasMatrix4();
        if (this.opaquePass)
          idx = i;
        else if (obj.fastTransparency)
          idx = indices[i];
        else
          idx = context.subid;
        if (typeof idx === "undefined")
          console.error("idx is undefined");
        baseofs = idx*obj.vOffsets.stride;
        ofs = baseofs + obj.vOffsets.radofs;
        sscale = obj.values[ofs];

        sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
        sphereMV.translate(obj.values[baseofs],
                             obj.values[baseofs+1],
                             obj.values[baseofs+2]);
        sphereMV.multRight(saveMV);
        this.mvMatrix = sphereMV;
        this.setnormMatrix2();
        this.setprmvMatrix();
        if (drawing) {
          if (nc > 1) {
            this.sphere.onecolor = obj.values.slice(baseofs + obj.vOffsets.cofs, baseofs + obj.vOffsets.cofs + 4);
          }
          this.drawSimple(this.sphere, subscene, context);
        } else 
          result = result.concat(this.getSpherePieces(context, i, obj));
      }
      if (drawing)
        this.disableArrays(obj, enabled);
      this.normMatrix = saveNorm;
      this.mvMatrix = saveMV;
      this.prmvMatrix = savePRMV;
        
      return result;
    };
    
    /**
     * Prepare clipplanes for drawing
     * @param { object } obj - clip planes object
     */
    rglwidgetClass.prototype.drawClipplanes = function(obj) {
      var count = obj.offsets.length,
        IMVClip = [];
      for (var i=0; i < count; i++) {
        IMVClip[i] = rglwidgetClass.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
      }
      obj.IMVClip = IMVClip;
      return [];
    };

    /**
     * Prepare linestrip for drawing
     * @param { object } obj - line strip object
     * @param { object } subscene 
     * @param { array } context 
     */    
    rglwidgetClass.prototype.drawLinestrip = function(obj, subscene, context) {
      var origIndices, i, j, margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      if (this.opaquePass)
        return this.drawSimple(obj, subscene, context);
      origIndices = context.indices.slice();
      for (i=0; i < origIndices.length; i++) {
        j = origIndices[i];
        if (j < obj.centers.length - 1) {
          context.indices = [j, j+1];
          this.drawSimple(obj, subscene, context);
        }
      }
      context.indices = origIndices;
      return [];
    };
          
    /**
     * Draw a sprites object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { object } context
     */
    rglwidgetClass.prototype.drawSprites = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sprites3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size),
          rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating),
          i,j,
          origMV = new CanvasMatrix4( this.mvMatrix ),
          origPRMV = null,
          origPR,
          pos, radius, userMatrix,
          result = [], margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!sprites3d) 
        return this.drawSimple(obj, subscene, context);
      
      if (!obj.initialized)
        this.initObj(obj);

      if (!obj.vertexCount)
        return [];
    
      is_transparent = is_transparent || obj.someHidden;
      
      var norigs = obj.vertices.length,
          savenorm = new CanvasMatrix4(this.normMatrix),
          iOrig, adj, offset;

      userMatrix = obj.userMatrix;
                   
      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } else
        norigs = 1;
          
      if (this.prmvMatrix !== null)
         origPRMV = new CanvasMatrix4( this.prmvMatrix );

      offset = obj.offset;
      
      if (fixed_size && !rotating) {
        origPR = this.prMatrix;
        this.prMatrix = new CanvasMatrix4();
      }
        
      for (iOrig=0; iOrig < norigs; iOrig++) {
        if (this.opaquePass)
          j = iOrig;
        else
          j = context.subid;
        pos = [].concat(obj.vertices[j]).concat(1.0);
        radius = obj.radii.length > 1 ? obj.radii[j][0] : obj.radii[0][0];
        this.mvMatrix = new CanvasMatrix4(userMatrix);
        adj = this.getAdj(obj, j, offset);
        this.mvMatrix.translate(1 - 2*adj[0], 1 - 2*adj[1], 1 - 2*adj[2]);
        this.mvMatrix.scale(radius, radius, radius);
        
        if (fixed_size) {
          var viewport = subscene.par3d.viewport,
            winwidth = viewport.width*this.canvas.width,
            winheight = viewport.height*this.canvas.height,
            scalex = 27/winwidth, scaley = 27/winheight,
              scale = Math.sqrt(scalex * scaley);
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            pos = rglwidgetClass.multVM(pos, origPR);
            this.mvMatrix.scale(scalex, scaley, scale);
          } else {
            scale = 4.0 * scale * subscene.par3d.zoom;
            this.mvMatrix.scale(scale, scale, scale);
          }
          this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          if (rotating)
            this.mvMatrix.multRight(origMV);
        } else {
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          } else {
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
            this.mvMatrix.multRight(origMV);
          }
        }
        this.setnormMatrix2();
        this.setprmvMatrix();
      
        for (i=0; i < obj.objects.length; i++)
          if (this.opaquePass)
            result = result.concat(this.drawObjId(obj.objects[i], subscene.id, context.concat(j)));
          else
            this.drawObjId(obj.objects[i], subscene.id, context);
      }
      this.normMatrix = savenorm;
      this.mvMatrix = origMV;
      if (fixed_size && !rotating)
        this.prMatrix = origPR;
      if (origPRMV !== null)
        this.prmvMatrix = origPRMV;
      return result;
    };
    
    /**
     * Draw object that might be in margin
     * @param { Object } obj - text object to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawMarginal = function(obj, subscene, context) {
      var margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      return this.drawSimple(obj, subscene, context);
    };
    
    /**
     * Draw bounding box and decorations
     * @param { Object } obj - bboxdeco to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawBBox = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          scale, bbox, indices,
          enabled = {}, drawing,
          result = [], idx, center, edges,
          saved;

      if (!obj.initialized)
        this.initBBox(obj);
      
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return result;
      
      this.setBbox(obj, subscene);
      
      saved = this.setBBoxMatrices(obj);
      
      bbox = obj.bbox;
      center = obj.center;

      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];

      if (!obj.cube.initialized) {
        this.initObj(obj.cube);
      }

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      this.cube.onecolor = obj.cube.onecolor;
      this.initShapeFromObj(this.cube, obj.cube);

      if (!this.opaquePass)
        indices = context.indices;

      if (this.opaquePass)
        idx = 0;
      else
        idx = context.subid;
      if (typeof idx === "undefined")
        console.error("idx is undefined");

      if (drawing) {
        this.drawSimple(this.cube, subscene, context);
      } else 
        result = result.concat(this.getCubePieces(context, obj));

      if (!obj.ticks.initialized) {
        obj.ticks.locations = this.getTickLocations(obj);
        obj.ticks.edges = undefined;
      }
      edges = this.getTickEdges(this.prmvMatrix);
      if (obj.needsAxisCallback) 
        this.doAxisCallback(obj, edges);
      if (!obj.ticks.edges || edges.toString() !== obj.ticks.edges.toString()) {
        obj.ticks.edges = edges;
        this.getTickVertices(obj.ticks);
        this.placeTickLabels(obj);
        this.setTickLabels(obj);
      }
      if (!obj.ticks.initialized) {
        this.initObj(obj.ticks);
        this.initObj(obj.labels);
      }
        
      if (drawing) {
        this.drawSimple(obj.ticks, subscene, context);
        this.drawSimple(obj.labels, subscene, context);

        this.disableArrays(obj, enabled);
      } else {
        result = result.concat(this.drawSimple(obj.ticks, subscene, context));
        result = result.concat(this.drawSimple(obj.labels, subscene, context));
      }

      this.restoreBBoxMatrices(saved);
        
      return result;
    };
    
    /**
     * Use ids to choose object to draw
     * @param { numeric } id - object to draw
     * @param { numeric } subscene
     * @param { array } context
     */   
    rglwidgetClass.prototype.drawObjId = function(id, subsceneid, context) {
      if (typeof id !== "number")
        this.alertOnce("drawObjId id is "+typeof id);

      return this.drawObj(this.getObj(id), this.getObj(subsceneid), context);
   };
   
    /**
     * Draw an object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { array } context
     */
    rglwidgetClass.prototype.drawObj = function(obj, subscene, context) {
      switch(obj.type) {
        case "abclines":
        case "surface":
          return this.drawSimple(obj, subscene, context);
        case "points":
        case "lines":  
        case "triangles":
        case "quads":
        case "text":
          return this.drawMarginal(obj, subscene, context);
        case "linestrip":
          return this.drawLinestrip(obj, subscene, context);
        case "planes":
          return this.drawPlanes(obj, subscene, context);
        case "spheres":
          return this.drawSpheres(obj, subscene, context);
        case "clipplanes":
          return this.drawClipplanes(obj);
        case "sprites":
          return this.drawSprites(obj, subscene, context);
        case "light":
          return [];
        case "bboxdeco":
          return this.drawBBox(obj, subscene, context);
      }
      
      console.error("drawObj for type = "+obj.type);
    };

    /**
     * Draw the background for a subscene
     * @param { number } id - id of background object
     * @param { number } subsceneid - id of subscene
     */
    rglwidgetClass.prototype.drawBackground = function(id, subsceneid, context) {
      var gl = this.gl || this.initGL(),
          obj = this.getObj(id),
          subscene,
          bg, i, savepr, saveinvpr, savemv, savenorm, m, bbox, result = [], 
          savedm = gl.getParameter(gl.DEPTH_WRITEMASK),
          savedt = gl.isEnabled(gl.DEPTH_TEST),
          saveblend = gl.isEnabled(gl.BLEND);

      if (!obj.initialized)
        this.initObj(obj);

      if (obj.colors.length) {
        bg = obj.colors[0];
        gl.depthMask(true);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.fogColor = bg;
      } else {
        this.fogColor = [0,0,0,0];
        obj.colors = [[0,0,0,0]];
      }
  
      this.fogType = obj.fogtype;
      this.fogScale = obj.fogscale;
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      if (typeof obj.quad !== "undefined") {
        savepr = this.prMatrix;
        saveinvpr = this.invPrMatrix;
        savemv = this.mvMatrix;
        this.prMatrix = new CanvasMatrix4();
        this.invPrMatrix = new CanvasMatrix4();
        this.mvMatrix = new CanvasMatrix4();
        for (i=0; i < obj.quad.length; i++)
          result = result.concat(this.drawObjId(obj.quad[i], subsceneid));
        this.prMatrix = savepr;
        this.invPrMatrix = saveinvpr;
        this.mvMatrix = savemv;

      } else if (obj.sphere) {
        subscene = this.getObj(subsceneid);
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        bbox = subscene.par3d.bbox;
        var center = [(bbox[0] + bbox[1])/2, 
                  (bbox[2] + bbox[3])/2, 
                  (bbox[4] + bbox[5])/2, 1],
            scale = subscene.par3d.scale,
            ranges = [bbox[1] - bbox[0], 
                  bbox[3] - bbox[2],
                  bbox[5] - bbox[4]],
            avgscale = rglwidgetClass.vlen(ranges)/Math.sqrt(3),
            aspect = [ranges[0]*scale[0]/avgscale,
                      ranges[1]*scale[1]/avgscale,
                      ranges[2]*scale[2]/avgscale],
            maxaspect = Math.max(aspect[0], aspect[1], aspect[2]),
            zoom = subscene.par3d.zoom;
        m = new CanvasMatrix4();
        m.rotate(90, 1, 0, 0);
        m.scale(zoom*2.0*maxaspect*ranges[0]/aspect[0], 
                zoom*2.0*maxaspect*ranges[1]/aspect[1],
                zoom*2.0*maxaspect*ranges[2]/aspect[2]);
        m.translate(center[0], center[1], center[2]);
        m.multRight(savemv);
        center = rglwidgetClass.multVM(center, savemv);
        m.translate(-center[0], -center[1], -center[2]);
        m.scale(1, 1, 0.25/zoom);
        m.translate(center[0], center[1], center[2]);
        this.mvMatrix = m;
        this.initShapeFromObj(this.sphere, obj);
        this.sphere.onecolor = obj.colors.length > 1 ? obj.colors[1] : obj.colors[0];
        
        this.normMatrix = new CanvasMatrix4();
        
        this.setnormMatrix2();
        this.setprmvMatrix();
        
        result = result.concat(this.drawSimple(this.sphere, subscene, context));
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;
      }
      gl.depthMask(savedm);
      if (savedt)
        gl.enable(gl.DEPTH_TEST);
      if (saveblend)
        gl.enable(gl.BLEND);
      return result;
    };

    /**
     * Draw a subscene
     * @param { number } subsceneid - id of subscene
     * @param { array } context 
     */
    rglwidgetClass.prototype.drawSubscene = function(subsceneid, context) {
      var sub = this.getObj(subsceneid),
          objects = this.scene.objects,
          clipids = sub.clipplanes,
          subids = sub.objects,
          subscene_has_faces = false,
          subscene_needs_sorting = false,
          flags, i, obj, result = [];
          
      if (sub.par3d.skipRedraw)
        return result;
      
      if (this.opaquePass) {
        for (i=0; i < subids.length; i++) {
      	  obj = objects[subids[i]];
          flags = obj.flags;
          if (typeof flags !== "undefined") {
            subscene_has_faces = subscene_has_faces || 
                            (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit) &&
                            !rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads));
            obj.is_transparent = obj.someHidden || 
              rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
            subscene_needs_sorting = subscene_needs_sorting || 
              obj.is_transparent ||
              rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort);
          }
        }
      }

      this.setViewport(subsceneid);

      this.setprMatrix(subsceneid);
      this.setInvPrMatrix();
      this.setmvMatrix(subsceneid);
      this.setnormMatrix2();
      this.setprmvMatrix();
      this.invMatrix = new CanvasMatrix4(this.mvMatrix);
      this.invMatrix.invert();
      
      if (this.opaquePass) {
        context = context.slice();
        context.push(subsceneid);
        
        this.doBlending(false);
        this.subsceneid = subsceneid;
        if (typeof this.sphere !== "undefined") // reset this.sphere.fastpieces; it will be recreated if needed
          this.sphere.fastpieces = undefined;
        if (typeof sub.backgroundId !== "undefined")
          result = result.concat(this.drawBackground(sub.backgroundId, subsceneid, context));
      }

      if (subids.length) {
            
        if (clipids.length > 0) {
          for (i = 0; i < clipids.length; i++)
            this.drawObjId(clipids[i], subsceneid);
        }
        
        subids = sub.opaque.concat(sub.transparent);
        if (this.opaquePass) {
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawObjId(subids[i], subsceneid, context));
          subids = sub.subscenes;
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawSubscene(subids[i], context));
        }
      }
      return result;
    };
    
    /**
     * Set the context for drawing transparently
     * @param { array } context
     */
    rglwidgetClass.prototype.setContext = function(context) {
      var result = [], objid, obj, type;
      context = context.slice();
      context.reverse();
      while (context.length > 0) {
        objid = context.pop();
        obj = this.getObj(objid);
        type = obj.type;
        switch (type) {
          case "subscene":
            this.drawSubscene(objid, false);
            break;
          case "sprites":
            result = result.concat(context.pop());
            break;
          case "spheres":
            // this.initSphereFromObj(obj);  // FIXME:  not needed?
            break;
          case "bboxdeco":
            result = result.concat(context.pop());
            break;
          default:
            console.error("bad type '", type, "' in setContext");
        }
      }
      return result;
    };
    
    /**
     * Draw the transparent pieces of a scene
     * @param {object} pieces
     */
    rglwidgetClass.prototype.drawPieces = function(pieces) {
      var i, prevcontext = [], context;
      for (i = 0; i < pieces.length; i++) {
        context = pieces[i].context.slice();
        if (context !== prevcontext) {
          prevcontext = context.slice();
          context = this.setContext(context);
          this.doBlending(true, pieces[i].objid);
        }
        this.drawObjId(pieces[i].objid, this.subsceneid, 
                       pieces[i]);
      }
    };
 
    /**
     * Draw the whole scene
     */
    rglwidgetClass.prototype.drawScene = function() {
      var wasDrawing = this.startDrawing(),
          pieces;
      if (!wasDrawing) {
        if (this.select.state !== "inactive")
          this.selectionChanged();

        this.doStartScene();
        this.opaquePass = true;
        pieces = this.drawSubscene(this.scene.rootSubscene, []);
        this.opaquePass = false;
        pieces = this.sortPieces(pieces);
        pieces = this.mergePieces(pieces);
        this.drawPieces(pieces);
      }
      this.stopDrawing(wasDrawing);
    };
</script>
<script>
    /**
     * Change the displayed subset
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The subset control data.
     */
    rglwidgetClass.prototype.subsetSetter = function(el, control) {
      if (typeof control.subscenes === "undefined" ||
          control.subscenes === null)
        control.subscenes = this.scene.rootSubscene;
      var value = Math.round(control.value),
          subscenes = [].concat(control.subscenes),
          fullset = [].concat(control.fullset),
          i, j, subsceneid,
          adds = [], deletes = [];
      if (rglwidgetClass.missing(value))
        value = control.value = 0;
      if (control.accumulate)
        for (i=0; i <= value; i++)
          adds = adds.concat(control.subsets[i]);
      else
        adds = adds.concat(control.subsets[value]);
      deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
      for (i = 0; i < subscenes.length; i++) {
        subsceneid = subscenes[i];
        if (typeof this.getObj(subsceneid) === "undefined")
          this.alertOnce("typeof object is undefined");
        for (j = 0; j < adds.length; j++)
          this.addToSubscene(adds[j], subsceneid);
        for (j = 0; j < deletes.length; j++)
          this.delFromSubscene(deletes[j], subsceneid);
      }
    };

    /**
     * Change the requested property
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The property setter control data.
     */
    rglwidgetClass.prototype.propertySetter = function(el, control)  {
      var value = control.value,
          values = [].concat(control.values),
          svals = [].concat(control.param),
          direct = values[0] === null,
          entries = [].concat(control.entries),
          ncol = entries.length,
          nrow = values.length/ncol,
          properties = rglwidgetClass.repeatToLen(control.properties, ncol),
          objids = rglwidgetClass.repeatToLen(control.objids, ncol),
          property, objid = objids[0],
          obj = this.getObj(objid),
          propvals, i, j, v1, v2, p, entry, gl, needsBinding,
          newprop, newid,

          getPropvals = function() {
            if (property === "userMatrix")
              return obj.par3d.userMatrix.getAsArray();
            else if (property === "scale" || property === "FOV" || property === "zoom")
              return [].concat(obj.par3d[property]);
            else
              return [].concat(obj[property]);
          },

          putPropvals = function(newvals) {
            if (newvals.length === 1)
              newvals = newvals[0];
            if (property === "userMatrix")
              obj.par3d.userMatrix.load(newvals);
            else if (property === "scale" || property === "FOV" || property === "zoom")
              obj.par3d[property] = newvals;
            else
              obj[property] = newvals;
          };

      if (direct && typeof value === "undefined")
        return;

      if (control.interp) {
        values = values.slice(0, ncol).concat(values).
                 concat(values.slice(ncol*(nrow-1), ncol*nrow));
        svals = [-Infinity].concat(svals).concat(Infinity);
        for (i = 1; i < svals.length; i++) {
          if (value <= svals[i]) {
            if (svals[i] === Infinity)
              p = 1;
            else
              p = (svals[i] - value)/(svals[i] - svals[i-1]);
            break;
          }
        }
      } else if (!direct) {
        value = Math.round(value);
      }

      for (j=0; j<entries.length; j++) {
        entry = entries[j];
        newprop = properties[j];
        newid = objids[j];

        if (newprop !== property || newid !== objid) {
          if (typeof property !== "undefined")
            putPropvals(propvals);
          property = newprop;
          objid = newid;
          obj = this.getObj(objid);
          propvals = getPropvals();
        }
        if (control.interp) {
          v1 = values[ncol*(i-1) + j];
          v2 = values[ncol*i + j];
          this.setElement(propvals, entry, p*v1 + (1-p)*v2);
        } else if (!direct) {
          this.setElement(propvals, entry, values[ncol*value + j]);
        } else {
          this.setElement(propvals, entry, value[j]);
        }
      }
      putPropvals(propvals);

      needsBinding = [];
      for (j=0; j < entries.length; j++) {
        if (properties[j] === "values" &&
            needsBinding.indexOf(objids[j]) === -1) {
          needsBinding.push(objids[j]);
        }
      }
      for (j=0; j < needsBinding.length; j++) {
        gl = this.gl || this.initGL();
        obj = this.getObj(needsBinding[j]);
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertices
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The vertext setter control data.
     */
    rglwidgetClass.prototype.vertexSetter = function(el, control)  {
      var svals = [].concat(control.param),
          j, k, p, a, propvals, stride, ofs, obj, entry,
          attrib, vertex, varies,
          ofss    = {x:"vofs", y:"vofs", z:"vofs",
                     red:"cofs", green:"cofs", blue:"cofs",
                     alpha:"cofs", radii:"radofs",
                     nx:"nofs", ny:"nofs", nz:"nofs",
                     ox:"oofs", oy:"oofs", oz:"oofs",
                     ts:"tofs", tt:"tofs"},
          pos     = {x:0, y:1, z:2,
                     red:0, green:1, blue:2,
                     alpha:3,radii:0,
                     nx:0, ny:1, nz:2,
                     ox:0, oy:1, oz:2,
                     ts:0, tt:1},
        values = control.values,
        direct = values === null,
        ncol,
        interp = control.interp,
        vertices = [].concat(control.vertices),
        attributes = [].concat(control.attributes),
        value = control.value, newval, aliases, alias;

      ncol = Math.max(vertices.length, attributes.length);

      if (!ncol)
        return;

      vertices = rglwidgetClass.repeatToLen(vertices, ncol);
      attributes = rglwidgetClass.repeatToLen(attributes, ncol);

      if (direct)
        interp = false;

      /* JSON doesn't pass Infinity */
      svals[0] = -Infinity;
      svals[svals.length - 1] = Infinity;

      for (j = 1; j < svals.length; j++) {
        if (value <= svals[j]) {
          if (interp) {
            if (svals[j] === Infinity)
              p = 1;
            else
              p = (svals[j] - value)/(svals[j] - svals[j-1]);
          } else {
            if (svals[j] - value > value - svals[j-1])
              j = j - 1;
          }
          break;
        }
      }

      obj = this.getObj(control.objid);
      // First, make sure color attributes vary in original
      if (typeof obj.vOffsets !== "undefined") {
      	varies = true;
        for (k = 0; k < ncol; k++) {
          attrib = attributes[k];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[attrib]];
            if (ofs < 0) {
              switch(attrib) {
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(control.objid);
      }
      propvals = obj.values;
      aliases = obj.alias;
      if (typeof aliases === "undefined")
        aliases = [];
      for (k=0; k<ncol; k++) {
        if (direct) {
          newval = value;
        } else if (interp) {
          newval = p*values[j-1][k] + (1-p)*values[j][k];
        } else {
          newval = values[j][k];
        }      	
        attrib = attributes[k];
        vertex = vertices[k];
        alias = aliases[vertex];
        if (obj.type === "planes" || obj.type === "clipplanes") {
          ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
          if (ofs >= 0) {
            if (ofs < 3) {
              if (obj.normals[vertex][ofs] !== newval) {  // Assume no aliases here...
              	obj.normals[vertex][ofs] = newval;
              	obj.initialized = false;
              }
            } else {
              if (obj.offsets[vertex][0] !== newval) {
              	obj.offsets[vertex][0] = newval;
              	obj.initialized = false;
              }
            }
            continue;
          }
        }
        // Not a plane setting...
        ofs = obj.vOffsets[ofss[attrib]];
        if (ofs < 0)
          this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
        else {
          stride = obj.vOffsets.stride;
          ofs = ofs + pos[attrib];
          entry = vertex*stride + ofs;
          propvals[entry] = newval;
          if (typeof alias !== "undefined")
            for (a = 0; a < alias.length; a++)
              propvals[alias[a]*stride + ofs] = newval;
        }
      }
      if (typeof obj.buf !== "undefined") {
        var gl = this.gl || this.initGL();
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertex properties by age
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The age setter control data.
     */
    rglwidgetClass.prototype.ageSetter = function(el, control) {
      var objids = [].concat(control.objids),
          nobjs = objids.length,
          time = control.value,
          births = [].concat(control.births),
          ages = [].concat(control.ages),
          steps = births.length,
          j = Array(steps),
          p = Array(steps),
          i, k, l, age, j0, propvals, stride, ofs, objid, obj,
          attrib, dim, varies, alias, aliases, a, d,
          attribs = ["colors", "alpha", "radii", "vertices",
                     "normals", "origins", "texcoords",
                     "x", "y", "z",
                     "red", "green", "blue"],
          ofss    = ["cofs", "cofs", "radofs", "vofs",
                     "nofs", "oofs", "tofs",
                     "vofs", "vofs", "vofs",
                     "cofs", "cofs", "cofs"],
          dims    = [3,1,1,3,
                     3,2,2,
                     1,1,1,
                     1,1,1],
          pos     = [0,3,0,0,
                     0,0,0,
                     0,1,2,
                     0,1,2];
      /* Infinity doesn't make it through JSON */
      ages[0] = -Infinity;
      ages[ages.length-1] = Infinity;
      for (i = 0; i < steps; i++) {
        if (births[i] !== null) {  // NA in R becomes null
          age = time - births[i];
          for (j0 = 1; age > ages[j0]; j0++);
          if (ages[j0] === Infinity)
            p[i] = 1;
          else if (ages[j0] > ages[j0-1])
            p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
          else
            p[i] = 0;
          j[i] = j0;
        }
      }
      // First, make sure color attributes vary in original
      for (l = 0; l < nobjs; l++) {
      	objid = objids[l];
      	obj = this.getObj(objid);
      	varies = true;
        if (typeof obj.vOffsets === "undefined")
          continue;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs < 0) {
              switch(attribs[k]) {
              	case "colors":
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(objid);
      }
      for (l = 0; l < nobjs; l++) {
        objid = objids[l];
        obj = this.getObj(objid);
        if (typeof obj.vOffsets === "undefined")
          continue;
        aliases = obj.alias;
        if (typeof aliases === "undefined")
          aliases = [];
        propvals = obj.values;
        stride = obj.vOffsets.stride;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs >= 0) {
              dim = dims[k];
              ofs = ofs + pos[k];
              for (i = 0; i < steps; i++) {
              	alias = aliases[i];
                if (births[i] !== null) {
                  for (d=0; d < dim; d++) {
                    propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
                    if (typeof alias !== "undefined")
                      for (a=0; a < alias.length; a++)
                        propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
                  }
                }
              }
            } else
              this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
          }
        }
        obj.values = propvals;
        if (typeof obj.buf !== "undefined") {
          var gl = this.gl || this.initGL();
          gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
          gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
        }
      }
    };

    /**
     * Bridge to old style control
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The bridge control data.
     */
    rglwidgetClass.prototype.oldBridge = function(el, control) {
      var attrname, global = window[control.prefix + "rgl"];
      if (global)
        for (attrname in global)
          this[attrname] = global[attrname];
      window[control.prefix + "rgl"] = this;
    };

    /**
     * Set up a player control
     * @param { Object } el - The player control element
     * @param { Object } control - The player data.
     */
    rglwidgetClass.prototype.Player = function(el, control) {
      var
        self = this,
        components = [].concat(control.components),
        buttonLabels = [].concat(control.buttonLabels),

        Tick = function() { /* "this" will be a timer */
          var i,
              nominal = this.value,
              slider = this.Slider,
              labels = this.outputLabels,
              output = this.Output,
              step;
          if (typeof slider !== "undefined" && nominal !== slider.value)
            slider.value = nominal;
          if (typeof output !== "undefined") {
            step = Math.round((nominal - output.sliderMin)/output.sliderStep);
            if (labels !== null) {
              output.innerHTML = labels[step];
            } else {
              step = step*output.sliderStep + output.sliderMin;
              output.innerHTML = step.toPrecision(output.outputPrecision);
            }
          }
          for (i=0; i < this.actions.length; i++) {
            this.actions[i].value = nominal;
          }
          self.applyControls(el, this.actions, false);
          self.drawScene();
        },

        OnSliderInput = function() { /* "this" will be the slider */
          this.rgltimer.value = Number(this.value);
          this.rgltimer.Tick();
        },

        addSlider = function(min, max, step, value) {
          var slider = document.createElement("input");
          slider.type = "range";
          slider.min = min;
          slider.max = max;
          slider.step = step;
          slider.value = value;
          slider.oninput = OnSliderInput;
          slider.sliderActions = control.actions;
          slider.sliderScene = this;
          slider.className = "rgl-slider";
          slider.id = el.id + "-slider";
          el.rgltimer.Slider = slider;
          slider.rgltimer = el.rgltimer;
          el.appendChild(slider);
        },

        addLabel = function(labels, min, step, precision) {
          var output = document.createElement("output");
          output.sliderMin = min;
          output.sliderStep = step;
          output.outputPrecision = precision;
          output.className = "rgl-label";
          output.id = el.id + "-label";
          el.rgltimer.Output = output;
          el.rgltimer.outputLabels = labels;
          el.appendChild(output);
        },

        addButton = function(which, label, active) {
          var button = document.createElement("input"),
              onclicks = {Reverse: function() { this.rgltimer.reverse();},
                    Play: function() { this.rgltimer.play();
                                       this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
                   Slower: function() { this.rgltimer.slower(); },
                   Faster: function() { this.rgltimer.faster(); },
                   Reset: function() { this.rgltimer.reset(); },
              	   Step:  function() { this.rgltimer.step(); }
              };
          button.rgltimer = el.rgltimer;
          button.type = "button";
          button.value = label;
          button.activeValue = label;
          button.inactiveValue = active;
          if (which === "Play")
            button.rgltimer.PlayButton = button;
          button.onclick = onclicks[which];
          button.className = "rgl-button";
          button.id = el.id + "-" + which;
          el.appendChild(button);
        };

        if (typeof control.reinit !== "undefined" && control.reinit !== null) {
          control.actions.reinit = control.reinit;
        }
        el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
                                        control.step, control.value, control.rate, control.loop, control.actions);
        for (var i=0; i < components.length; i++) {
          switch(components[i]) {
            case "Slider": addSlider(control.start, control.stop,
                                   control.step, control.value);
              break;
            case "Label": addLabel(control.labels, control.start,
                                   control.step, control.precision);
              break;
            default:
              addButton(components[i], buttonLabels[i], control.pause);
          }
        }
        el.rgltimer.Tick();
    };

    /**
     * Apply all registered controls
     * @param { Object } el - DOM element of the control
     * @param { Object } x - List of actions to apply
     * @param { boolean } [draw=true] - Whether to redraw after applying
     */
    rglwidgetClass.prototype.applyControls = function(el, x, draw) {
      var self = this, reinit = x.reinit, i, control, type;
      for (i = 0; i < x.length; i++) {
        control = x[i];
        type = control.type;
        self[type](el, control);
      }
      if (typeof reinit !== "undefined" && reinit !== null) {
        reinit = [].concat(reinit);
        for (i = 0; i < reinit.length; i++)
          self.getObj(reinit[i]).initialized = false;
      }
      if (typeof draw === "undefined" || draw)
        self.drawScene();
    };

    /**
     * Handler for scene change
     * @param { Object } message - What sort of scene change to do?
     */
    rglwidgetClass.prototype.sceneChangeHandler = function(message) {
      var self = document.getElementById(message.elementId).rglinstance,
          objs = message.objects, mat = message.material,
          root = message.rootSubscene,
          initSubs = message.initSubscenes,
          redraw = message.redrawScene,
          skipRedraw = message.skipRedraw,
          deletes, subs, allsubs = [], i,j;
      if (typeof message.delete !== "undefined") {
        deletes = [].concat(message.delete);
        if (typeof message.delfromSubscenes !== "undefined")
          subs = [].concat(message.delfromSubscenes);
        else
          subs = [];
        for (i = 0; i < deletes.length; i++) {
          for (j = 0; j < subs.length; j++) {
            self.delFromSubscene(deletes[i], subs[j]);
          }
          delete self.scene.objects[deletes[i]];
        }
      }
      if (typeof objs !== "undefined") {
        Object.keys(objs).forEach(function(key){
          key = parseInt(key, 10);
          self.scene.objects[key] = objs[key];
          self.initObjId(key);
          var obj = self.getObj(key),
              subs = [].concat(obj.inSubscenes), k;
          allsubs = allsubs.concat(subs);
          for (k = 0; k < subs.length; k++)
            self.addToSubscene(key, subs[k]);
        });
      }
      if (typeof mat !== "undefined") {
        self.scene.material = mat;
      }
      if (typeof root !== "undefined") {
        self.scene.rootSubscene = root;
      }
      if (typeof initSubs !== "undefined")
        allsubs = allsubs.concat(initSubs);
      allsubs = self.unique(allsubs);
      for (i = 0; i < allsubs.length; i++) {
        self.initSubscene(allsubs[i]);
      }
      if (typeof skipRedraw !== "undefined") {
        root = self.getObj(self.scene.rootSubscene);
        root.par3d.skipRedraw = skipRedraw;
      }
      if (redraw)
        self.drawScene();
    };
</script>
<script>    /**
     * Methods related to selection
     * @name ___METHODS_FOR_SELECTION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Respond to brush change
     */
    rglwidgetClass.prototype.selectionChanged = function() {
      var i, j, k, id, subid = this.select.subscene, subscene,
          objids, obj,
          p1 = this.select.region.p1, p2 = this.select.region.p2,
          filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
          someHidden;
      if (!subid)
        return;
      subscene = this.getObj(subid);
      objids = subscene.objects;
      filter = this.scene.crosstalk.filter;
      this.setmvMatrix(subid);
      this.setprMatrix(subid);
      this.setprmvMatrix();
      xmin = Math.min(p1.x, p2.x);
      xmax = Math.max(p1.x, p2.x);
      ymin = Math.min(p1.y, p2.y);
      ymax = Math.max(p1.y, p2.y);
      for (i = 0; i < objids.length; i++) {
      	id = objids[i];
      	j = this.scene.crosstalk.id.indexOf(id);
      	if (j >= 0) {
      	  keys = this.scene.crosstalk.key[j];
      	  obj = this.getObj(id);
      	  someHidden = false;
      	  for (k = 0; k < keys.length; k++) {
      	    if (filter && filter.indexOf(keys[k]) < 0) {
      	      someHidden = true;
      	      continue;
      	    }
      	    v = [].concat(obj.vertices[k]).concat(1.0);
            v = rglwidgetClass.multVM(v, this.prmvMatrix);
            x = v[0]/v[3];
            y = v[1]/v[3];
            z = v[2]/v[3];
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
              selection.push(keys[k]);
            } else
              someHidden = true;
      	  }
      	  obj.someHidden = someHidden && (filter || selection.length);
      	  obj.initialized = false;
      	  /* Who should we notify?  Only shared data in the current subscene, or everyone? */
      	  if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
      	    handle = this.scene.crosstalk.sel_handle[j];
      	    handle.set(selection, {rglSubsceneId: this.select.subscene});
      	  }
      	}
      }
    };
    
    /**
     * Respond to selection or filter change from crosstalk
     * @param { Object } event - crosstalk event
     * @param { boolean } filter - filter or selection?
     */
    rglwidgetClass.prototype.selection = function(event, filter) {
      	var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
      	    selection, someHidden;

      	// Record the message and find out if this event makes some objects have mixed values:
      	
      	crosstalk = this.scene.crosstalk;
      	
      	if (filter) {
      	  filter = crosstalk.filter = event.value;
      	  selection = crosstalk.selection;
      	} else {  
          selection = crosstalk.selection = event.value;
          filter = crosstalk.filter;
      	}
        ids = crosstalk.id;
        for (i = 0; i < ids.length ; i++) {
          obj = this.getObj(ids[i]);
          obj.initialized = false;
          keys = crosstalk.key[i];
          someHidden = false;
          for (j = 0; j < keys.length && !someHidden; j++) {
            if ((filter && filter.indexOf(keys[j]) < 0) ||
                (selection.length && selection.indexOf(keys[j]) < 0))
                someHidden = true;
          }
          obj.someHidden = someHidden;
        }
        this.drawScene();
    };
    
    /**
     * Clear the selection brush
     * @param { number } except - Subscene that should ignore this request
     */
    rglwidgetClass.prototype.clearBrush = function(except) {
      if (this.select.subscene !== except) {
        this.select.region = {p1: {x:Infinity, y:Infinity}, 
                              p2: {x:Infinity, y:Infinity}};
        this.selectionChanged();
        this.select.state = "inactive";
        this.delFromSubscene(this.scene.brushId, this.select.subscene);
      }
      this.drawScene();
    };
    
    /**
     * Set the vertices in the selection box object
     */
    rglwidgetClass.prototype.initSelection = function(id) {
      if (typeof this.select.region === "undefined")
        return;
      var obj = this.getObj(id),
          p1 = this.select.region.p1,
          p2 = this.select.region.p2;
          
      obj.vertices = [[p1.x, p1.y, 0.0],
                      [p2.x, p1.y, 0.0],
                      [p2.x, p2.y, 0.0],
                      [p1.x, p2.y, 0.0],
                      [p1.x, p1.y, 0.0]];
    };
</script>
<script>
/* globals rgltimerClass: true */

/**
 * The class of an rgl timer object
 * @class
*/

/**
 * Construct an rgltimerClass object
 * @constructor
 * @param { function } Tick - action when timer fires
 * @param { number } startTime - nominal start time in seconds
 * @param { number } interval - seconds between updates
 * @param { number } stopTime - nominal stop time in seconds
 * @param { number } stepSize - nominal step size
 * @param { number } value - current nominal time
 * @param { number } rate - nominal units per second
 * @param { string } loop - "none", "cycle" or "oscillate"
 * @param { Object } actions - list of actions
 */
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
  this.enabled = false;
  this.timerId = 0;
  /** nominal start time in seconds */
  this.startTime = startTime;   
  /** current nominal time */      
  this.value = value;
  /** seconds between updates */                 
  this.interval = interval;
  /** nominal stop time */           
  this.stopTime = stopTime;
  /** nominal step size */           
  this.stepSize = stepSize;
  /** nominal units per second */           
  this.rate = rate;
  /** "none", "cycle", or "oscillate" */                   
  this.loop = loop;
  /** real world start time */                   
  this.realStart = undefined;
  /** multiplier for fast-forward or reverse */         
  this.multiplier = 1;                
  this.actions = actions;
  this.Tick = Tick;
};


    /**
     * Methods related to players
     * @name ___METHODS_FOR_PLAYERS___
     * @memberof rgltimerClass
     * @kind function
     * @instance
     */

  /**
   * Start playing
   * @memberof rgltimerClass
   */
  rgltimerClass.prototype.play = function() {
    if (this.enabled) {
      this.enabled = false;
      window.clearInterval(this.timerId);
      this.timerId = 0;
      return;
    }
    var tick = function(self) {
      var now = new Date();
      self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
      self.forceToRange();
      if (typeof self.Tick !== "undefined") {
        self.Tick(self.value);
      }

    };
    this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
    this.timerId = window.setInterval(tick, 1000*this.interval, this);
    this.enabled = true;
  };

  /**
   * Force value into legal range
   */
  rgltimerClass.prototype.forceToRange = function() {
    if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
      if (!this.loop) {
        this.reset();
      } else {
        var cycle = this.stopTime - this.startTime + this.stepSize,
            newval = (this.value - this.startTime) % cycle + this.startTime;
        if (newval < this.startTime) {
          newval += cycle;
        }
        this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
        this.value = newval;
      }
    }
  };

  /**
   * Reset to start values
   */
  rgltimerClass.prototype.reset = function() {
    this.value = this.startTime;
    this.newmultiplier(1);
    if (typeof this.Tick !== "undefined") {
        this.Tick(this.value);
    }
    if (this.enabled)
      this.play();  /* really pause... */
    if (typeof this.PlayButton !== "undefined")
      this.PlayButton.value = "Play";
  };

  /**
   * Increase the multiplier to play faster
   */
  rgltimerClass.prototype.faster = function() {
    this.newmultiplier(Math.SQRT2*this.multiplier);
  };

  /**
   * Decrease the multiplier to play slower
   */
  rgltimerClass.prototype.slower = function() {
    this.newmultiplier(this.multiplier/Math.SQRT2);
  };

  /**
   * Change sign of multiplier to reverse direction
   */
  rgltimerClass.prototype.reverse = function() {
    this.newmultiplier(-this.multiplier);
  };

  /**
   * Set multiplier for play speed
   * @param { number } newmult - new value
   */
  rgltimerClass.prototype.newmultiplier = function(newmult) {
    if (newmult !== this.multiplier) {
      this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
      this.multiplier = newmult;
    }
  };

  /**
   * Take one step
   */
  rgltimerClass.prototype.step = function() {
    this.value += this.rate*this.multiplier;
    this.forceToRange();
    if (typeof this.Tick !== "undefined")
      this.Tick(this.value);
  };
</script>
<script>/**
 * Pretty function from R
 * @name ___PRETTY_FROM_R___
 * @memberof rglwidgetClass
 * @kind function
 * @instance
 */


/* This file is translated from pretty.c, which was
 taken from the R sources, r61744 of src/appl/pretty.c,
 with minimal changes */

/*
 *  R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995-2012  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/**     
 * Construct pretty values to cover an interval
 * @param { number } lo - lower end of interval
 * @param { number } up - upper end of interval
 * @param { number } ndiv - requested number of divisions
 * @param { number } min_n - minimum divisions
 * @param { number } shrink_sml - if too many cells, amount to shrink by
 * @param { number } high_u_fact - bias in favour of larger units
 * @param { number } eps_correction - correction to bounds
 * @param { Boolean } return_bounds - whether to return bounds
 * @description
 * Pretty Intervals

 * Constructs m "pretty" values which cover the given interval	*lo <= *up
 *	m ~= *ndiv + 1	(i.e., ndiv := approximate number of INTERVALS)
 *
 * It is not quite clear what should happen for	 *lo = *up;
 * S itself behaves quite funilly, then.
 *
 * In my opinion, a proper 'pretty' should always ensure
 * *lo < *up, and hence *ndiv >=1 in the result.
 * However, in S and here, we allow  *lo == *up, and *ndiv = 0.
 * Note however, that we are NOT COMPATIBLE to S. [Martin M.]
 *
 * NEW (0.63.2): ns, nu are double (==> no danger of integer overflow)
 *
 * We determine
 * if the interval (up - lo) is ``small'' [<==>	 i_small == TRUE, below].
 * For the ``i_small'' situation, there is a parameter  shrink_sml,
 * the factor by which the "scale" is shrunk.		~~~~~~~~~~
 * It is advisable to set it to some (smaller) integer power of 2,
 * since this enables exact floating point division.
 */
rglwidgetClass.prototype.R_pretty = function(
  lo, up, ndiv, min_n, shrink_sml, high_u_fact,
  eps_correction, return_bounds) {
  /* From version 0.65 on, we had rounding_eps := 1e-5, before, r..eps = 0
   * 1e-7 is consistent with seq.default() */
  var rounding_eps = 1e-7,  h = high_u_fact[0],
                                           h5 = high_u_fact[1], 
                                                           dx, cell, unit, base, U, ns, nu, k, i_small,
                                                           DBL_EPSILON = Number.EPSILON,
                                                           DBL_MIN = Number.MIN_VALUE,
                                                           DBL_MAX = Number.MAX_VALUE;
  
  dx = up - lo;
  /* cell := "scale"	here */
  if (dx === 0 && up === 0) { /*  up == lo == 0	 */
  cell = 1;
    i_small = true;
  } else {
    cell = Math.max(Math.abs(lo), Math.abs(up));
    /* U = upper bound on cell/unit */
    U = (1 + (h5 >= 1.5*h+0.5)) ? 1/(1+h) : 1.5/(1+h5);
    /* added times 3, as several calculations here */
    i_small = dx < cell * U * Math.max(1,ndiv) * DBL_EPSILON *3;
  }
  
  /*OLD: cell = FLT_EPSILON+ dx / *ndiv; FLT_EPSILON = 1.192e-07 */
  if(i_small) {
    if(cell > 10)
      cell = 9 + cell/10;
    cell *= shrink_sml;
    if(min_n > 1) cell /= min_n;
  } else {
    cell = dx;
    if(ndiv > 1) cell /= ndiv;
  }
  
  if(cell < 20*DBL_MIN) {
    /* warning(_("Internal(pretty()): very small range.. corrected")); */
    cell = 20*DBL_MIN;
  } else if(cell * 10 > DBL_MAX) {
    /* warning(_("Internal(pretty()): very large range.. corrected")); */
    cell = 0.1*DBL_MAX;
  }
  base = Math.pow(10, Math.floor(Math.log10(cell))); /* base <= cell < 10*base */
    
    /* unit : from { 1,2,5,10 } * base
     *	 such that |u - cell| is small,
     * favoring larger (if h > 1, else smaller)  u  values;
     * favor '5' more than '2'  if h5 > h  (default h5 = .5 + 1.5 h) */
    unit = base;
    if((U = 2*base)-cell <  h*(cell-unit)) { unit = U;
      if((U = 5*base)-cell < h5*(cell-unit)) { unit = U;
        if((U =10*base)-cell <  h*(cell-unit)) unit = U; }}
    /* Result: c := cell,  u := unit,  b := base
     *	c in [	1,	      (2+ h) /(1+h) ] b ==> u=  b
     *	c in ( (2+ h)/(1+h),  (5+2h5)/(1+h5)] b ==> u= 2b
     *	c in ( (5+2h)/(1+h), (10+5h) /(1+h) ] b ==> u= 5b
     *	c in ((10+5h)/(1+h),	         10 ) b ==> u=10b
     *
     *	===>	2/5 *(2+h)/(1+h)  <=  c/u  <=  (2+h)/(1+h)	*/
    
    ns = Math.floor(lo/unit+rounding_eps);
    nu = Math.ceil (up/unit-rounding_eps);
    
    if(eps_correction && (eps_correction > 1 || !i_small)) {
      if(lo !== 0.0) lo *= (1- DBL_EPSILON); else lo = -DBL_MIN;
      if(up !== 0.0) up *= (1+ DBL_EPSILON); else up = +DBL_MIN;
    }
    
    while(ns*unit > lo + rounding_eps*unit) ns--;
    
    while(nu*unit < up - rounding_eps*unit) nu++;
    
    k = Math.floor(0.5 + nu - ns);
    if(k < min_n) {
      /* ensure that	nu - ns	 == min_n */
      
      k = min_n - k;
      if(ns >= 0) {
        nu += k/2;
        ns -= k/2 + k%2;/* ==> nu-ns = old(nu-ns) + min_n -k = min_n */
      } else {
        ns -= k/2;
        nu += k/2 + k%2;
      }
      ndiv = min_n;
    } else {
      ndiv = k;
    }
    if(return_bounds) { /* if()'s to ensure that result covers original range */
      if(ns * unit < lo) lo = ns * unit;
      if(nu * unit > up) up = nu * unit;
    } else {
      lo = ns;
      up = nu;
    }
    return {lo:lo, up:up, ndiv:ndiv, unit:unit};
};
</script>
<script>    /**
     * Methods related to axes
     * @name ___METHODS_FOR_AXES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Choose edges for ticks
     * @param { Matrix } prmv - projection-model-view matrix
     */
    rglwidgetClass.prototype.getTickEdges = function(prmv){
      var vertices = [[0,0,0,1], [0,0,1,1],
                      [0,1,0,1], [0,1,1,1],
                      [1,0,0,1], [1,0,1,1],
                      [1,1,0,1], [1,1,1,1]], 
           dim, i, j, k, edges, hull, step, result = [], proj = [],

        // Filter to edges that are on sides that would
        // be shown with a filled backing.
        
      has_back = function(edge) {
          var normals = [[], []],
              verts = [vertices[edge[0]], 
                       vertices[edge[1]]], 
              normal, m, n;
          n = 0;
          for (m=0; m<3; m++) {
            if (verts[0][m] === verts[1][m]) {
              normals[n] = [0,0,0,1];
              normals[n][m] = 2*verts[0][m] - 1;
              n++;
            }
          }
          for (n=0; n<2; n++) {
            normal = rglwidgetClass.multVM(normals[n], self.normMatrix);
            if (normal[2] < 0 ||
                (normal[2] === 0 && normal[0] < 0))
              return true;
          }
          return false;
        }, self = this;
        
      for (i = 0; i < vertices.length; i++) {
        proj[i] = rglwidgetClass.multVM(vertices[i], prmv);
        proj[i][0] = proj[i][0]/proj[i][3];
        proj[i][1] = proj[i][1]/proj[i][3];
        proj[i][2] = i;
      }
      hull = rglwidgetClass.chull(proj.slice());  
      for (i = 0; i < hull.length; i++)
        hull[i] = hull[i][2];
      hull.push(hull[0]);
      for (dim = 0; dim < 3; dim++) { 
        edges = [];
        step = Math.pow(2, 2-dim);
        for (i = 0; i < 4; i++) {
          j = (dim === 0) ? i : (dim === 1) ? i + 2*(i>1) : 2*i;
          for (k = 0; k < hull.length - 1; k++) {
            if ((hull[k] === j && hull[k+1] === j + step) ||
                (hull[k] === j+step && hull[k+1] === j))
          
              edges.push([j, j+step], [j+step, j]);
          }
        }

        edges = edges.filter(has_back);
        
        // Find the edge with a vertex closest
        // to the bottom left corner
        if (edges.length) {
          var best, best2, val = Infinity, newval;
          for (i = 0; i < edges.length; i++) {
            j = edges[i][0];
            newval = proj[j][0] + proj[j][1];
            if (newval < val) {
              best = j;
              best2 = edges[i][1];
              val = newval;
            }
          }
          if (typeof best !== "undefined") {
            result[dim] = vertices[best].slice(0,3);
            result[dim][dim] = undefined;
          } else
            result[dim] = undefined;
        }
      }
      return result;
    };
    
    /**
     * Choose tick locations
     * @param { Object } obj - The bboxdeco
    */
    rglwidgetClass.prototype.getTickLocations = function(obj){
      var dim, i, limits, locations = [], result = [[],[],[]], value,
          len, delta, range, bbox = obj.bbox;
      obj.needsAxisCallback = false;
      for (dim = 0; dim < 3; dim++) {
        limits = bbox.slice(2*dim, 2*dim + 2);
        range = limits[1] - limits[0];
        switch(obj.axes.mode[dim]) {
        case "custom":
          for (i=0; i < obj.vertices.length; i++) {
            value = (obj.vertices[i][dim] - limits[0])/range;
            if (typeof value !== "undefined" &&
                !isNaN(value))
              result[dim].push(value);
          }
          break;
        case "fixedstep":
          len = Math.floor(range/obj.axes.step[dim]);
          delta = obj.axes.step[dim];
          for (i = 0; i < len; i++)
            result[dim].push(i*delta);          
          break;
        case "fixednum":
          len = obj.axes.nticks[dim];
          delta = (len > 1) ? range/(len-1) : 0;
          for (i = 0; i < len; i++)
            result[dim].push(i*delta/range);
          break;
        case "pretty":
          locations = this.R_pretty(limits[0], limits[1], 5,
                                  2, // min_n
                                  0.75, // shrink_sml
                                  [1.5, 2.75], // high_u_fact
                                  0, // eps_correction
                                  0); // return_bounds)  
          for (i = locations.lo; i <= locations.up; i++) {
            value = (i*locations.unit - limits[0])/range;
            if (0 < value && value < 1)
              result[dim].push(value);
          }
          break;
        case "user":
          obj.needsAxisCallback = true;
          break;
        }
      }
      return result;
    };
    
    /**
     * Set tick vertices
     * @param { Object } ticks - the tick object
     * @param { Array }  edges - Which edges get the ticks?
    */
    rglwidgetClass.prototype.getTickVertices = function(ticks) {
      var dim, i, j, vertices = [], locations, 
          edges = ticks.edges, edge;
      for (dim = 0; dim < 3; dim++) {
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) 
            if (typeof edges[dim] !== "undefined") {
              edge = edges[dim].slice();
              edge[dim] = locations[i];
              vertices.push(edge);
              edge = edge.slice();
              for (j = 0; j < 3; j++)       
                if ((dim < 2 && j === 1 - dim) || 
                    (dim === 2 && j === 0))
                  edge[j] += 2*(edge[j] - 0.5)/ticks.axes.marklen[dim];
              vertices.push(edge);
            }
        }
      ticks.vertices = vertices;
      ticks.vertexCount = vertices.length;
      ticks.values = new Float32Array(rglwidgetClass.flatten(vertices));
      ticks.initialized = false;
    };
    
    /**
     * Set tick label positions
     * @param { Object } obj - the bbox object
    */
    rglwidgetClass.prototype.placeTickLabels = function(obj) {
      var ticks = obj.ticks, labels = obj.labels, i,j,k,
          vertices = [], tickvertices = ticks.vertices, 
          vertex, locations, dim, edges = obj.ticks.edges;
      j = 0;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) {
            if (isNaN(locations[i]))
              continue;
            while (j < tickvertices.length && 
                   tickvertices[j][dim] !== locations[i]) j++;
            if (j >= tickvertices.length)
              break;
            vertex = tickvertices[j].slice();
            for (k = 0; k < 3; k++)
              vertex[k] += 2*(tickvertices[j+1][k] - vertex[k]);
            vertices.push(vertex);
            j += 2;
          }
        }
      labels.vertices = vertices;
      labels.centers = labels.vertices;
      labels.initialized = false;
    };  
     
    /**
     * Set tick labels
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setTickLabels = function(obj) {
      var ticks = obj.ticks, mode, locations, labels = [],
      start = 0, nticks, dim, i, limits, range, values, max,
      edges = obj.ticks.edges;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        mode = obj.axes.mode[dim];
        nticks = obj.axes.nticks[dim]; // used on input only for custom!
        if (mode === "custom") 
          labels = labels.concat(obj.texts.slice(start, start + nticks));
        else {
          limits = obj.bbox.slice(2*dim, 2*(dim+1));
          range = limits[1] - limits[0];
          locations = ticks.locations[dim];
          max = -Infinity;
          values = [];
          for (i = 0; i < locations.length; i++) {
            values.push(limits[0] + range*locations[i]);
            max = Math.max(max, Math.abs(values[i]));
          }
          for (i = 0; i < locations.length; i++) {
            if (Math.abs(values[i])/max < Math.pow(10, -5))
              values[i] = 0;
            labels.push(rglwidgetClass.signif(values[i], 4).toString());
          }
          obj.axes.nticks[dim] = locations.length;  
        }
        start += nticks;
      }
      obj.labels.texts = labels;
    };

    /**
     * Set bboxdeco bbox and center vector 
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setBbox = function(obj, subscene) {
      var i, expand, center = [], bbox;
      if (!obj.initialized)
        this.initBBox(obj);
        
      bbox = [].concat(subscene.par3d.bbox);
      for (i = 0; i < 3; i++) {
        expand = obj.axes.expand[i];
        center[i] = (bbox[2*i] + bbox[2*i + 1])/2;
        bbox[2*i] = center[i] - expand*(bbox[2*i + 1] - center[i]);
        bbox[2*i+1] = center[i] + expand*(bbox[2*i + 1] - center[i]);
      }
      obj.bbox = bbox;
      obj.center = center;
    };

    rglwidgetClass.prototype.setBBoxMatrices = function(obj) {
      var saved = {normMatrix: new CanvasMatrix4(this.normMatrix),
                   mvMatrix: new CanvasMatrix4(this.mvMatrix)},
          bboxNorm, bboxMV, bbox = obj.bbox, scale;
          
      bboxNorm = new CanvasMatrix4();
      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];
      bboxNorm.scale(1/scale[0], 1/scale[1], 1/scale[2]);
      bboxNorm.multRight(saved.normMatrix);
      this.normMatrix = bboxNorm;

      bboxMV = new CanvasMatrix4();
      bboxMV.scale(scale[0], scale[1], scale[2]);
      bboxMV.translate(bbox[0], bbox[2], bbox[4]);
      bboxMV.multRight(saved.mvMatrix);
      this.mvMatrix = obj.mvMatrix = bboxMV;
      
      if (this.prmvMatrix === null)
        saved.prmvMatrix = null;
      else
        saved.prmvMatrix = new CanvasMatrix4(this.prmvMatrix);
        
      this.setprmvMatrix();
      obj.prmvMatrix = this.prmvMatrix;
      
      return saved;
    };
    
    rglwidgetClass.prototype.restoreBBoxMatrices = function(saved) {
      this.normMatrix = saved.normMatrix;
      this.mvMatrix   = saved.mvMatrix;
      this.prmvMatrix = saved.prmvMatrix;
    };
    
    rglwidgetClass.prototype.getMarginParameters = function(bboxdeco, material) {
      // Assume we've run this.setBbox(bboxdeco, subscene);
      var bbox = bboxdeco.bbox,
          edge = [].concat(material.edge),
          saved, edges, i, 
          at = material.margin, line, level, trans, scale;

      if (material.floating) {
        saved = this.setBBoxMatrices(bboxdeco);
        edges = this.getTickEdges(this.prmvMatrix)[at];
        this.restoreBBoxMatrices(saved);
        if (typeof edges !== "undefined")
          for (i = 0; i < 3; i++) {
            if (edges[i] < 1) edges[i] = -1;
              edge[i] = edge[i]*edges[i];
        } else
          return undefined;
      }
      switch(at) {
      case 0: line = 1;
              level = 2;
              break;
      case 1: line = 0;
              level = 2;
              break;
      case 2: line = 0;
              level = 1;
              break;
      }
      scale = [edge[0]*(bbox[1]-bbox[0])/bboxdeco.axes.marklen[0], 
               edge[1]*(bbox[3]-bbox[2])/bboxdeco.axes.marklen[1], 
               edge[2]*(bbox[5]-bbox[4])/bboxdeco.axes.marklen[2]];
      trans = [edge[0] === 1 ? bbox[1] : bbox[0],
               edge[1] === 1 ? bbox[3] : bbox[2],
               edge[2] === 1 ? bbox[5] : bbox[4]];
      return {at: at, line: line, level: level, trans: trans, scale: scale};        
    };
    
    rglwidgetClass.prototype.fixVertex = function(orig, parms, center, bbox) {
      var vertex = [0,0,0];
      if (rglwidgetClass.missing(orig[0]))
        vertex[parms.at] = center[parms.at];
      else if (orig[0] === "-Inf")
        vertex[parms.at] = bbox[2*parms.at];
      else if (orig[0] === "Inf")
        vertex[parms.at] = bbox[2*parms.at + 1];
      else
        vertex[parms.at] = orig[0];
      vertex[parms.line] = parms.scale[parms.line]*orig[1] + 
          parms.trans[parms.line];
      vertex[parms.level] = parms.scale[parms.level]*orig[2] + 
          parms.trans[parms.level];
      return vertex;
    };
    
    rglwidgetClass.prototype.fixNormal = function(orig, parms) {
      var vertex = [0,0,0];
      vertex[parms.at] = orig[0];
      vertex[parms.line] = orig[1]/parms.scale[parms.line];
      vertex[parms.level] = orig[2]/parms.scale[parms.level];
      return vertex;
    };

    rglwidgetClass.prototype.marginVecToDataVec = function(obj, subscene) {
      var bboxdeco = this.getBBoxDeco(subscene),
          center, bbox, parms, parmsjson,
          orig = obj.orig, 
          vertices = [], normals = [],
          centers = [], i, vertex;
      if (typeof orig === "undefined") {
        orig = {vert: obj.vertices,
                norm: obj.normals,
                cent: obj.centers,
                doNormals: typeof obj.normals !== "undefined",
                doCenters: typeof obj.centers !== "undefined",
                parms: ""
               };
        obj.orig = orig;
      }

      if (typeof bboxdeco !== "undefined") {
        this.setBbox(bboxdeco, subscene);
        center = bboxdeco.center;
        bbox = bboxdeco.bbox;
        parms = this.getMarginParameters(bboxdeco, obj.material);
        if (typeof parms === "undefined")
          return false;  /* axis is not currently shown */
        
        parmsjson = JSON.stringify(parms);
        if (parmsjson === orig.parms)
          return true;  /* nothing has changed */
    
        orig.parms = parmsjson;
        
        for (i=0; i < orig.vert.length; i++) {
          vertex = this.fixVertex(orig.vert[i], parms, center, bbox);
          vertices.push(vertex);
        }
        obj.vertices = vertices;
        if (orig.doNormals) {
          for (i=0; i < orig.norm.length; i++) {
            vertex = this.fixNormal(orig.norm[i], parms);
            normals.push(vertex);
          }
          obj.normals = normals;
        }
        if (orig.doCenters) {
          for (i=0; i < orig.cent.length; i++) {
            vertex = this.fixVertex(orig.cent[i], parms, center, bbox);
            centers.push(vertex);
          }
          obj.centers = centers;
        }
        
        obj.initialized = false;
        return true;
      } else {
        console.warn("bboxdeco not found");
        return false;
      }
    };

    rglwidgetClass.prototype.doAxisCallback = function(obj, edges) {
      var i, j, code, axis, fn;
      for (i = 0; i < 3; i++) {
        if (obj.axes.mode[i] === "user") {
          axis = ["x", "y", "z"][i];
          if (typeof obj.callbacks !== "undefined" &&
              typeof (code = obj.callbacks[axis]) !== "undefined") {
            if (typeof edges[i] !== "undefined")
              for (j = 0; j < 3; j++)
                if (typeof edges[i][j] !== "undefined")
                  axis = axis + (edges[i][j] > 0 ? "+" : "-");
            
          /* jshint evil:true */
            fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
            fn.call(this, axis);
          }
        }
      }
    };
</script>
<script>/**
     * Methods related to animations
     * @name ___METHODS_FOR_ANIMATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Binary search
     * @param x - x coordinates in increasing order
     * @param newx - value to find, assumed to be in the range of x
     * @result index of largest x value below newx
     */
    rglwidgetClass.bisect = function(x, newx) {
      var lo = 0, hi = x.length - 1, mid;
      while (lo < hi - 1) {
        mid = Math.round((lo + hi)/2);
        if (x[mid] < newx)
          lo = mid;
        else
          hi = mid;
      }
      return lo;
    };
    
    /**
     * Step interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.step = function(x, v, newx) {
      var n, lo;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      return v[lo];
    };
    
    /**
     * Linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.lerp = function(x, v, newx) {
      var i, n, lo, hi, alpha, result;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      alpha = (newx - x[lo])/(x[hi] - x[lo]);
      result = v[lo];
      n = result.length;
      if (typeof n !== "undefined") {
        for (i = 0; i < n; i++)
          result[i] = (1 - alpha)*result[i] + alpha*v[hi][i];
      } else
        result = (1 - alpha)*result + alpha*v[hi];
      return result;
    };
    
    /**
     * Spherical linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - a matrix of unit quaternions
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.slerp = function(x, v, newx) {
      var n, lo, hi, alpha, result,
          p0, p1, dot, Omega, alpha0, alpha1, len;
      if (newx <= x[0])
        return v[0];    
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      p0 = v[lo];
      p1 = v[hi];
      dot = p0[0]*p1[0] + 
            p0[1]*p1[1] +
            p0[2]*p1[2] +
            p0[3]*p1[3];
      if (dot < 0) {
        p1 = [-p1[0], -p1[1], -p1[2], -p1[3]];
        dot = -dot;
      }
      if (dot >= 1)
        result = p1;
      else {
        alpha = (newx - x[lo])/(x[hi] - x[lo]);
        Omega = Math.acos(dot);
        alpha0 = Math.sin((1 - alpha)*Omega);
        alpha1 = Math.sin(alpha*Omega);
        result = [alpha0*p0[0] + alpha1*p1[0],
                  alpha0*p0[1] + alpha1*p1[1],
                  alpha0*p0[2] + alpha1*p1[2],
                  alpha0*p0[3] + alpha1*p1[3]];
      }
      len = Math.sqrt(result[0]*result[0] +
                      result[1]*result[1] +
                      result[2]*result[2] +
                      result[3]*result[3]);
      return [result[0]/len,
              result[1]/len,
              result[2]/len,
              result[3]/len];
    };

    /**
     * Rotate using unit quaternion
     * @param q - a single unit quaternion
     */
    rglwidgetClass.rotateByQuaternion = function(M, q) {

    var xx = q[0]*q[0],
        xy = q[0]*q[1],
        xz = q[0]*q[2],
        xw = q[0]*q[3],
        yy = q[1]*q[1],
        yz = q[1]*q[2],
        yw = q[1]*q[3],
        zz = q[2]*q[2],
        zw = q[2]*q[3],
        matrix = new CanvasMatrix4();
      matrix.m11 = 1 - 2*(yy + zz);
      matrix.m12 = 2*(xy + zw);
      matrix.m13 = 2*(xz - yw);
        
      matrix.m21 = 2*(xy - zw);
      matrix.m22 = 1 - 2*(xx + zz);
      matrix.m23 = 2*(yz + xw);

      matrix.m31 = 2*(xz + yw);
      matrix.m32 = 2*(yz - xw);
      matrix.m33 = 1 - 2*(xx + yy);

      M.multRight(matrix);      
    };
</script>
<script>/* globals CanvasMatrix4: true */
/* globals WebGLFloatArray */
/* jshint eqeqeq: false */
/*
 * Copyright (C) 2009 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
 * cleaned up.
 */
/*
    CanvasMatrix4 class

    This class implements a 4x4 matrix. It has functions which
    duplicate the functionality of the OpenGL matrix stack and
    glut functions.

    IDL:

    [
        Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
        Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
        Constructor()                                   // create new CanvasMatrix4 with identity matrix
    ]
    interface CanvasMatrix4 {
        attribute float m11;
        attribute float m12;
        attribute float m13;
        attribute float m14;
        attribute float m21;
        attribute float m22;
        attribute float m23;
        attribute float m24;
        attribute float m31;
        attribute float m32;
        attribute float m33;
        attribute float m34;
        attribute float m41;
        attribute float m42;
        attribute float m43;
        attribute float m44;

        void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
        void load(in sequence<float> array);                // copy 16 floats into the matrix
        sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
        WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
        void makeIdentity();                                // replace the matrix with identity
        void transpose();                                   // replace the matrix with its transpose
        void invert();                                      // replace the matrix with its inverse

        void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
        void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
        void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
                    in float x, in float y, in float z);    // (angle is in degrees)
        void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
        void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
        void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
                   in float bottom, in float top,
                   in float near, in float far);
        void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
                     in float bottom, in float top,
                     in float near, in float far);
        void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
                         in float zNear, in float zFar);
        void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
                    in float ctrx, in float ctry, in float ctrz,    // values on the right
                    in float upx, in float upy, in float upz);
    }
*/

CanvasMatrix4 = function(m)
{
    if (typeof m == 'object') {
        if ("length" in m && m.length >= 16) {
            this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
            return;
        }
        else if (m instanceof CanvasMatrix4) {
            this.load(m);
            return;
        }
    }
    this.makeIdentity();
};

CanvasMatrix4.prototype.load = function()
{
    if (arguments.length == 1 && typeof arguments[0] == 'object') {
        var matrix = arguments[0];

        if ("length" in matrix && matrix.length == 16) {
            this.m11 = matrix[0];
            this.m12 = matrix[1];
            this.m13 = matrix[2];
            this.m14 = matrix[3];

            this.m21 = matrix[4];
            this.m22 = matrix[5];
            this.m23 = matrix[6];
            this.m24 = matrix[7];

            this.m31 = matrix[8];
            this.m32 = matrix[9];
            this.m33 = matrix[10];
            this.m34 = matrix[11];

            this.m41 = matrix[12];
            this.m42 = matrix[13];
            this.m43 = matrix[14];
            this.m44 = matrix[15];
            return;
        }

        if (arguments[0] instanceof CanvasMatrix4) {

            this.m11 = matrix.m11;
            this.m12 = matrix.m12;
            this.m13 = matrix.m13;
            this.m14 = matrix.m14;

            this.m21 = matrix.m21;
            this.m22 = matrix.m22;
            this.m23 = matrix.m23;
            this.m24 = matrix.m24;

            this.m31 = matrix.m31;
            this.m32 = matrix.m32;
            this.m33 = matrix.m33;
            this.m34 = matrix.m34;

            this.m41 = matrix.m41;
            this.m42 = matrix.m42;
            this.m43 = matrix.m43;
            this.m44 = matrix.m44;
            return;
        }
    }

    this.makeIdentity();
};

CanvasMatrix4.prototype.getAsArray = function()
{
    return [
        this.m11, this.m12, this.m13, this.m14,
        this.m21, this.m22, this.m23, this.m24,
        this.m31, this.m32, this.m33, this.m34,
        this.m41, this.m42, this.m43, this.m44
    ];
};

CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
    return new WebGLFloatArray(this.getAsArray());
};

CanvasMatrix4.prototype.makeIdentity = function()
{
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;

    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;

    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;

    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
};

CanvasMatrix4.prototype.transpose = function()
{
    var tmp = this.m12;
    this.m12 = this.m21;
    this.m21 = tmp;

    tmp = this.m13;
    this.m13 = this.m31;
    this.m31 = tmp;

    tmp = this.m14;
    this.m14 = this.m41;
    this.m41 = tmp;

    tmp = this.m23;
    this.m23 = this.m32;
    this.m32 = tmp;

    tmp = this.m24;
    this.m24 = this.m42;
    this.m42 = tmp;

    tmp = this.m34;
    this.m34 = this.m43;
    this.m43 = tmp;
};

CanvasMatrix4.prototype.invert = function()
{
    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-8)
        return null;

    this._makeAdjoint();

    // Scale the adjoint matrix to get the inverse
    this.m11 /= det;
    this.m12 /= det;
    this.m13 /= det;
    this.m14 /= det;

    this.m21 /= det;
    this.m22 /= det;
    this.m23 /= det;
    this.m24 /= det;

    this.m31 /= det;
    this.m32 /= det;
    this.m33 /= det;
    this.m34 /= det;

    this.m41 /= det;
    this.m42 /= det;
    this.m43 /= det;
    this.m44 /= det;
};

CanvasMatrix4.prototype.translate = function(x,y,z)
{
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    if (z === undefined)
        z = 0;

    var matrix = new CanvasMatrix4();
    matrix.m41 = x;
    matrix.m42 = y;
    matrix.m43 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.scale = function(x,y,z)
{
    if (x === undefined)
        x = 1;
    if (z === undefined) {
        if (y === undefined) {
            y = x;
            z = x;
        }
        else
            z = 1;
    }
    else if (y === undefined)
        y = x;

    var matrix = new CanvasMatrix4();
    matrix.m11 = x;
    matrix.m22 = y;
    matrix.m33 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
    // angles are in degrees. Switch to radians
    angle = angle / 180 * Math.PI;

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;

    // normalize
    var length = Math.sqrt(x * x + y * y + z * z);
    if (length === 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    var mat = new CanvasMatrix4();

    // optimize case where axis is along major axis
    if (x == 1 && y === 0 && z === 0) {
        mat.m11 = 1;
        mat.m12 = 0;
        mat.m13 = 0;
        mat.m21 = 0;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 2 * sinA * cosA;
        mat.m31 = 0;
        mat.m32 = -2 * sinA * cosA;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y == 1 && z === 0) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 0;
        mat.m13 = -2 * sinA * cosA;
        mat.m21 = 0;
        mat.m22 = 1;
        mat.m23 = 0;
        mat.m31 = 2 * sinA * cosA;
        mat.m32 = 0;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y === 0 && z == 1) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 2 * sinA * cosA;
        mat.m13 = 0;
        mat.m21 = -2 * sinA * cosA;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 0;
        mat.m31 = 0;
        mat.m32 = 0;
        mat.m33 = 1;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else {
        var x2 = x*x;
        var y2 = y*y;
        var z2 = z*z;

        mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
        mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
        mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
        mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
        mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
        mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
        mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
        mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
        mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    }
    this.multRight(mat);
};

CanvasMatrix4.prototype.multRight = function(mat)
{
    var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
               this.m13 * mat.m31 + this.m14 * mat.m41);
    var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
               this.m13 * mat.m32 + this.m14 * mat.m42);
    var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
               this.m13 * mat.m33 + this.m14 * mat.m43);
    var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
               this.m13 * mat.m34 + this.m14 * mat.m44);

    var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
               this.m23 * mat.m31 + this.m24 * mat.m41);
    var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
               this.m23 * mat.m32 + this.m24 * mat.m42);
    var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
               this.m23 * mat.m33 + this.m24 * mat.m43);
    var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
               this.m23 * mat.m34 + this.m24 * mat.m44);

    var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
               this.m33 * mat.m31 + this.m34 * mat.m41);
    var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
               this.m33 * mat.m32 + this.m34 * mat.m42);
    var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
               this.m33 * mat.m33 + this.m34 * mat.m43);
    var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
               this.m33 * mat.m34 + this.m34 * mat.m44);

    var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
               this.m43 * mat.m31 + this.m44 * mat.m41);
    var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
               this.m43 * mat.m32 + this.m44 * mat.m42);
    var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
               this.m43 * mat.m33 + this.m44 * mat.m43);
    var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
               this.m43 * mat.m34 + this.m44 * mat.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.multLeft = function(mat)
{
    var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
               mat.m13 * this.m31 + mat.m14 * this.m41);
    var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
               mat.m13 * this.m32 + mat.m14 * this.m42);
    var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
               mat.m13 * this.m33 + mat.m14 * this.m43);
    var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
               mat.m13 * this.m34 + mat.m14 * this.m44);

    var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
               mat.m23 * this.m31 + mat.m24 * this.m41);
    var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
               mat.m23 * this.m32 + mat.m24 * this.m42);
    var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
               mat.m23 * this.m33 + mat.m24 * this.m43);
    var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
               mat.m23 * this.m34 + mat.m24 * this.m44);

    var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
               mat.m33 * this.m31 + mat.m34 * this.m41);
    var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
               mat.m33 * this.m32 + mat.m34 * this.m42);
    var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
               mat.m33 * this.m33 + mat.m34 * this.m43);
    var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
               mat.m33 * this.m34 + mat.m34 * this.m44);

    var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
               mat.m43 * this.m31 + mat.m44 * this.m41);
    var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
               mat.m43 * this.m32 + mat.m44 * this.m42);
    var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
               mat.m43 * this.m33 + mat.m44 * this.m43);
    var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
               mat.m43 * this.m34 + mat.m44 * this.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
    var tx = (left + right) / (left - right);
    var ty = (top + bottom) / (bottom - top);
    var tz = (far + near) / (near - far);

    var matrix = new CanvasMatrix4();
    matrix.m11 = 2 / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;
    matrix.m21 = 0;
    matrix.m22 = 2 / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;
    matrix.m31 = 0;
    matrix.m32 = 0;
    matrix.m33 = -2 / (far - near);
    matrix.m34 = 0;
    matrix.m41 = tx;
    matrix.m42 = ty;
    matrix.m43 = tz;
    matrix.m44 = 1;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
    var matrix = new CanvasMatrix4();
    var A = (right + left) / (right - left);
    var B = (top + bottom) / (top - bottom);
    var C = -(far + near) / (far - near);
    var D = -(2 * far * near) / (far - near);

    matrix.m11 = (2 * near) / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;

    matrix.m21 = 0;
    matrix.m22 = 2 * near / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;

    matrix.m31 = A;
    matrix.m32 = B;
    matrix.m33 = C;
    matrix.m34 = -1;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = D;
    matrix.m44 = 0;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
    var top = Math.tan(fovy * Math.PI / 360) * zNear;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    this.frustum(left, right, bottom, top, zNear, zFar);
};

CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
    var matrix = new CanvasMatrix4(),
        xx, xy, xz;

    // Make rotation matrix

    // Z vector
    var zx = eyex - centerx;
    var zy = eyey - centery;
    var zz = eyez - centerz;
    var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
    if (mag) {
        zx /= mag;
        zy /= mag;
        zz /= mag;
    }

    // Y vector
    var yx = upx;
    var yy = upy;
    var yz = upz;

    // X vector = Y cross Z
    xx =  yy * zz - yz * zy;
    xy = -yx * zz + yz * zx;
    xz =  yx * zy - yy * zx;

    // Recompute Y = Z cross X
    yx = zy * xz - zz * xy;
    yy = -zx * xz + zz * xx;
    yx = zx * xy - zy * xx;

    // cross product gives area of parallelogram, which is < 1.0 for
    // non-perpendicular unit-length vectors; so normalize x, y here

    mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
    if (mag) {
        xx /= mag;
        xy /= mag;
        xz /= mag;
    }

    mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
    if (mag) {
        yx /= mag;
        yy /= mag;
        yz /= mag;
    }

    matrix.m11 = xx;
    matrix.m12 = xy;
    matrix.m13 = xz;
    matrix.m14 = 0;

    matrix.m21 = yx;
    matrix.m22 = yy;
    matrix.m23 = yz;
    matrix.m24 = 0;

    matrix.m31 = zx;
    matrix.m32 = zy;
    matrix.m33 = zz;
    matrix.m34 = 0;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = 0;
    matrix.m44 = 1;
    matrix.translate(-eyex, -eyey, -eyez);

    this.multRight(matrix);
};

// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
    return a * d - b * c;
};

CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
    return a1 * this._determinant2x2(b2, b3, c2, c3) -
         b1 * this._determinant2x2(a2, a3, c2, c3) +
         c1 * this._determinant2x2(a2, a3, b2, b3);
};

CanvasMatrix4.prototype._determinant4x4 = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
         b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
         c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
         d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

CanvasMatrix4.prototype._makeAdjoint = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    // Row column labeling reversed since we transpose rows & columns
    this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">An introduction to qualpalr</h1>
<h4 class="author">Johan Larsson</h4>
<h4 class="date">2023-09-12</h4>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p><code>qualpalr</code> generates distinct qualitative color palettes,
primarily for use in R graphics. Given <code>n</code> (the number of
colors to generate), along with a subset in the <a href="https://en.wikipedia.org/wiki/HSL_and_HSV">hsl color space</a> (a
cylindrical representation of the RGB color space) <code>qualpalr</code>
attempts to find the <code>n</code> colors in the provided color
subspace that <em>maximize the smallest pairwise color difference</em>.
This is done by projecting the color subset from the HSL color space to
the DIN99d space. DIN99d is (approximately) perceptually uniform, that
is, the euclidean distance between two colors in the space is
proportional to their perceived difference.</p>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<p><code>qualpalr</code> relies on one basic function,
<code>qualpal()</code>, which takes as its input <code>n</code> (the
number of colors to generate) and <code>colorspace</code>, which can be
either</p>
<ul>
<li>a list of numeric vectors <code>h</code> (hue from -360 to 360),
<code>s</code> (saturation from 0 to 1), and <code>l</code> (lightness
from 0 to 1), all of length 2, specifying a min and max.</li>
<li>a character vector specifying one of the predefined color subspaces,
which at the time of writing are <em>pretty</em>, <em>pretty_dark</em>,
<em>rainbow</em>, and <em>pastels</em>.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(qualpalr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>pal <span class="ot">&lt;-</span> <span class="fu">qualpal</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="fu">list</span>(<span class="at">h =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">360</span>), <span class="at">s =</span> <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="fl">0.6</span>), <span class="at">l =</span> <span class="fu">c</span>(<span class="fl">0.5</span>, <span class="fl">0.85</span>)))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Adapt the color space to deuteranomaly of severity 0.7</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>pal <span class="ot">&lt;-</span> <span class="fu">qualpal</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">colorspace =</span> <span class="st">&quot;pretty&quot;</span>, <span class="at">cvd =</span> <span class="st">&quot;deutan&quot;</span>, <span class="at">cvd_severity =</span> <span class="fl">0.7</span>)</span></code></pre></div>
<p>The resulting object, <code>pal</code>, is a list with several color
tables and a distance matrix based on the DIN99d color difference
formula.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>pal</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ---------------------------------------- </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Colors in the HSL color space </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Hue Saturation Lightness</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #DCC670  60       0.46      0.61</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #5C70C8 248       0.48      0.60</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #99867A 353       0.50      0.62</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #D9DED5 151       0.48      0.83</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #B2B6E0 280       0.48      0.78</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  ---------------------------------------- </span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; DIN99d color difference distance matrix </span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         #DCC670 #5C70C8 #99867A #D9DED5</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #5C70C8      29                        </span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #99867A      16      20                </span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #D9DED5      15      24      17        </span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; #B2B6E0      23      15      17      15</span></span></code></pre></div>
<p>Methods for <code>pairs</code> and <code>plot</code> have been
written for <code>qualpal</code> objects to help visualize the
results.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Multidimensional scaling plot</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(pal)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Pairs plot in the Lab color space</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(pal, <span class="at">colorspace =</span> <span class="st">&quot;DIN99d&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><img src="data:image/png;base64,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" /></p>
<p>The colors are most easily used in R by accessing
<code>pal$hex</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(maps)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(<span class="st">&quot;france&quot;</span>, <span class="at">fill =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> pal<span class="sc">$</span>hex, <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="details" class="section level2">
<h2>Details</h2>
<p><code>qualpal</code> begins by generating a point cloud out of the
HSL color subspace provided by the user, using a quasi-random sobol
sequence from <a href="https://cran.r-project.org/package=randtoolbox">randtoolbox</a>.
Here is the color subset in HSL with settings
<code>h = c(-200, 120), s = c(0.3, 0.8), l = c(0.4, 0.9)</code>.</p>
<pre><code>#&gt; This build of rgl does not include OpenGL functions.  Use
#&gt;  rglwidget() to display results, e.g. via options(rgl.printRglwidget = TRUE).
#&gt; Warning in randtoolbox::sobol(1000, dim = 3, scrambling = 2): scrambling is
#&gt; currently disabled.</code></pre>
<div class="figure">
<div id="rgl97316" style="width:288px;height:288px;" class="rglWebGL html-widget " aria-labelledby="rgl97316-aria"></div>
<script type="application/json" data-for="rgl97316">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":1,"objects":{"7":{"id":7,"type":"points","material":{"lit":false},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"9":{"id":9,"type":"text","material":{"lit":false,"margin":0,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["HSL"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"10":{"id":10,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"6","colors":"7","texts":[["x"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"11":{"id":11,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["y"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"12":{"id":12,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"12","colors":"13","texts":[["L"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"4":{"id":4,"type":"background","material":{},"colors":"15","centers":"16","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":"17","centers":"18","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"8":{"id":8,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"19","colors":"20","axes":{"mode":["pretty","pretty","pretty"],"step":[0.5,0.5,0.1000000014901161],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.029999971389771,1.029999971389771,1.029999971389771]},"draw_front":true,"flags":32769},"1":{"id":1,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,5.620292663574219],"modelMatrix":[[0.8383641839027405,0,0,0.002952601062133908],[0,0.2854519784450531,2.49704909324646,-1.623473525047302],[0,-0.7842727899551392,0.9088515639305115,-6.209969997406006],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863703489303589,-20.26050758361816],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[0.8383641839027405,0.8346056938171387,2.657304048538208],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-0.7943815588951111,0.7873378396034241,-0.7930490374565125,0.7957932949066162,0.4004882872104645,0.8995116949081421],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,8,7,9,10,11,12,5],"subscenes":[],"flags":36113}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":288,"height":288,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1000,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":15,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":16,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":17,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":19,"componentType":5126,"count":10,"type":"VEC3"},{"bufferView":20,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":12000,"byteOffset":0},{"buffer":0,"byteLength":4000,"byteOffset":12000},{"buffer":0,"byteLength":12000,"byteOffset":16000},{"buffer":0,"byteLength":12,"byteOffset":28000},{"buffer":0,"byteLength":4,"byteOffset":28012},{"buffer":0,"byteLength":12,"byteOffset":28016},{"buffer":0,"byteLength":12,"byteOffset":28028},{"buffer":0,"byteLength":4,"byteOffset":28040},{"buffer":0,"byteLength":12,"byteOffset":28044},{"buffer":0,"byteLength":12,"byteOffset":28056},{"buffer":0,"byteLength":4,"byteOffset":28068},{"buffer":0,"byteLength":12,"byteOffset":28072},{"buffer":0,"byteLength":12,"byteOffset":28084},{"buffer":0,"byteLength":4,"byteOffset":28096},{"buffer":0,"byteLength":12,"byteOffset":28100},{"buffer":0,"byteLength":16,"byteOffset":28112},{"buffer":0,"byteLength":3,"byteOffset":28128},{"buffer":0,"byteLength":4,"byteOffset":28131},{"buffer":0,"byteLength":3,"byteOffset":28135},{"buffer":0,"byteLength":120,"byteOffset":28140},{"buffer":0,"byteLength":4,"byteOffset":28260}],"buffers":[{"byteLength":28264,"bytes":"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\nUD7NTO4+Rc32vqi7FT5mph0/rf8QP9iJ2b5mpl0/9Z7oPo7f2T5mpj0/GzG0vuzHMb/NTPs+\nGHoEPmgKDr9mpk0/eZC2PW5FPT9mpg0/8yPNPk8yszzNTNs+jzYdv75Ghr5mpi0/YlvxvjMO\n4r5mpgU/rxI7P5/Hnz5mpkU/u6v6vTFiBj9mpmU/vVfLPp3QG79mpiU/j/dhvbRE6r5mpjU/\n6VWfPio0HT/NTOs+N1ISP0yLMb5mphU/kMNCv98hKr1mplU/Jo8RvzDCB75mpkE/bns/P2uy\nuL1mpgE/IiEBPmLX1D5mpiE/B3IXPR5fLb9mpmE/pLm2PvoXw77NTOM+YkeQvpnsKD9mpjE/\niwIIPyh/sT5mplE/EK/xvrkXIb9mphE/4dKVviyGQ75mplk/scsjP2XEGD5mphk/vcf3vKrT\nDT/NTPM+9PWTPi08Lb9mpjk/A141vs94Fb9mpgk/1KrsPrq/HT9mpkk/xdbcPm7VX75mpik/\nsn4xv5A0qz3NTNM+Hc8gv391qDxmpl8/Hew5P8pKlb5mph8/77mKPg0X3z7NTP8+KzMWvtGS\nMr9mpj8//0BKPvkxvb5mpg8/7M/CvbWRKj9mpk8/MFoMP5vENz5mpi8/CdoWv0HH7L7NTN8+\nOOiTvp7a7b5mpjc/CkcTPxIr5z7NTO8+rDydvroVEz9mphc/DDcYP3R0CL9mplc/BsSuPXAE\nGb/NTM8+A3AhPh3vPz9mpic/VtXxPnVWfbxmpkc/g7Uov3rlXL5mpgc/5jDjvqm9gb3NTPc+\n4zIrPzf/D75mpjs/NFhhPkNRDD9mpls/xRXLvNrcQb9mphs/HVzKPnPsAL9mpis/0dx7vv5b\nQD/NTNc+aKLvPlYWgD5mpgs/Sc/2vmKoCb9mpks/Y/H9vj68h75mpiM/Fpw7P1RG1j1mpmM/\n2YdLPL9Jwj5mpkM/uwRTPjAqIb9mpgM/gm88voGr6r5mplM/DFfwPp8MBj9mphM/tf8FP9Wm\npr7NTOc+zgNCvxEwIz5mpjM/Hi0OvxDBET7NTOk+ps8dP6ro175mpjQ/UPuSPk05lj5mplQ/\no6mNvvxTHL9mphQ/gzwMPna2+r5mpkQ/Y/tdPWpXNT9mpgQ/DlwfP/kgez1mpiQ/kiw0v+PX\nrL5mpmQ/GiinvgPYqr5mpgw/lXsfP2v+mD5mpkw/kKIlvl8PFD9mpiw/tNvjPub8Hr/NTNk+\n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\nIL9mhjQ/p40xPm3V775mhiQ/8lV8u2q4ND9mhmQ/Wx0cP40/4z1mhkQ/4qkrv4a5yL5mhgQ/\nvuuUvql0s75mhiw/4Gu5/+XQpv8tLd//xYni/5TQG//IZGT/ud/y/0x4z//zwan/otCL/7gk\nuP/YzO//4+NY/80uY/+K8fH/tOXv/+g7WP+brzX/snrq/8x4vv/U9s3/5sKd/yND4f9/qtT/\ntTgf/4rSQf/loPP/TDW//+3chv/oy9r/V93H/4re1//JHmb/u7Rt/8W38P+2SMD/ve2a//Tb\n0/9dmOr/tbni/9qZPv83qy3/623L/6Zd2//q98D/35ie/yOo1f9Hvsj/8J+z/9fgb/9aFbv/\n78Dr/3DnSf+wb0D/hp/p/yp8tv/ufHL/1Oi4/7dB3/+qptr/1aor/9Zpqf/I9+v/ZNrB//jF\n4f/e0Z//PCbY/9m84f+V2UX/rUAx/3O06v84Urb/67KD/8fwvf/pRNX/onPb/6G1Gf+9UWj/\noOPt/5rI2//QJi3/tNde/+K/9v+xJYj/be5n/+fSrv82PeD/0t7z/+iGXv92t0//6Jrr/3xb\nyv/y8LP/44On/xnNxf/M7en/4ViX/8m2Mf+fivD/vE7M/8ryqP/JnJD/JWe0/6Cp6v/ljSX/\ngdR2//fS8P95Qqj/0ueC/+28wv9Fw+X/NsbM//CRrf/t79P/kWDi/9uH1/9Pwx//2H9K/6zB\n9f9wo8L/8sG//8Phkf+eH9P/qqfq/+WvLf+eNHb/bObC/6vp2P/jMp3/moA7/3hw5P+zZc//\n4PW//+aUjv8aj9v/lqXP/75jJ/92z1b/87Hv/3I2z//r8ZP/8NTc/2Hb4/82jaf/6HWB/9/t\nr/+ZNub/45nS/zTdIP/Go3b/yM30/zh91f/zrpn/oNd2/6Icsf/Mw+n/39BO/74vbv9/7uL/\nYcC+//Cwx//e3IL/URzF//PM9P+L61b/wmg//5Oz7f8vMaL/6Ltp/7fatv/WO6b/wpba/5jM\nJf/XWlz/uuP2/3nR4P/BGDj/tcZT/8uo8P+tS5//oOmQ//DbyP9Tbub/vdXr/+JeR/94vyn/\n2Xnw/35u2v/58c//36nF/zDZuf+k4tT/3CuO/97Daf/Szfn/mDC3/7rsev/mxMD/Spzc/8XP\n8f/okk7/W7dA/+uM4f+GYrT/5u2p/9p9kv8cqrv/XLLS//W5vf/E1Jr/iCjH/+Or1P893DP/\nqHUn/2Nr7P9Ec7r/66uT/9vyzP/fVuj/mHzj/8i9F//MU4P/rPLu/yzHsf/wgrf/7efF/2tQ\n4//Fg9D/ZrIh/89eRP+gx/L/c4DQ//bizP+m55v/4yC+/9K36//E40D/nUZT/37R5f/a7/D/\n4mmP/8nMP/+4mvH/2FPV/8n2tP/bqo//IlbJ/5XJ5f/eIR3/q8xv/+bF9f80Man/6cRx/+6t\n1/8z6K//jOfL/9sYlP/RsGL/v771/343nP+65W7/6qup/zCi5P/S2/H/5I9f/2LRM//yke//\ngFLR//H0r//SkaT/Jbq+/4O6yP/21Nn/2eal/4ss4P/vvOX/WudE/7B5O/+CkOn/M3nI/++f\njP/c7c7/zlvg/5OC2f+9qB7/1kWJ/6b16v9Bxr//75i5//Xz0f+EW+z/3Ibh/1/MG//FfmL/\ntczx/11k2v/34r//nd6Z/9Mkov/QtuD/rdk+/6kuNf9tx+r/wejt/+RLbf+Zo03/s4jn/8JO\ntP+x7qD/3aJy/xg7uP+kwtv/1j0p/6XXaP/tx/f/OSm3/+7Tcf/ottL/QOC9/7vm3v/cRZL/\ntJwu/4d17P/IZN3/4fnI/+Kpn/8lg9z/d4na/7dnG/9quFr/7aTh/3c8tf/b6of/8MDJ/0nP\n6P8rhK//7G1u/9XltP+mPdz/06bE/y3OK//Trmb/w8P2/12DzP/zybb/puSF/84Z0P/f1fT/\n6edg/7lQdP+d7Ov/RdHE//OixP/Sy4P/RCG1/+vG7v+Q5FH/ylEr/4Sy8f9DTKL/5rp//73s\nuf/kQb3/yJzo/7XkIf/Sc3z/zu33/4fQ1v+8IUn/ytRJ/8ep9P/GOLv/qO6P/+rc0v9fgN7/\nos3r/+Y1KP9xnTD/xWfm/29oxf/y5Lv/4Yy+/x3Qov9szrP/9cXi/+bPlP8mHN//2bDp/6Hi\nOP+ZRkH/drrk/zZj1P/zupf/3/PX/+Zk4P+tk9f/vcYl/9RWef+18vX/ndXl/+AiOP+4ynj/\n48z1/6w2kv+G6Xn/7tS0/ztO6P/L1+b/3HNW/3K8Nv/hhez/YUHR//Ppn//Tf6X/ILOi/8vz\n8v/qVIv/wLw+/62R7f+7YL7/xu+u/92dgf8cWcP/kJLe/86PIP9Y21P/97fk/3gppv/C6mT/\n4ayu/zSo2v9Eo7L/6Yyf/+rwxf+WT+f/4XXS/zjAFv/Jh07/pbTx/2+m1//41M7/xNqs/7Ux\n1f/Dven/38FH/7oseP947tf/MreX/+x8vP/m3cL/Wkzc/9Sm4v+R2y3/3XZr/87n+f9WcML/\n78ep/5Leev+/Gq//2MXz/9zrTf/AOVn/i+Tt/6vW5f/eMz//iKsm/7Vj7f/VXLX/v/W6/9e+\nmf8mMsr/f6fg/8dHGv+Gxlr/7K/x/2pSr//q45b/8c7d/1rm3P+Dyb7/qiJl/8u1Qv+qm/D/\nqS2//7Xvff/qycH/TJXg/7G66//kkDj/TKA8/+Z20v+fatL/7fbG/+iUof8av+L/TdXX//Wu\nxf/Z2or/WSHE/+7V7v+M4WP/y2s6/5Sy8P83ep3/5XBv/9Tqqv+qMOT/lZTg/9SaIf+7eqT/\nwfLi/1nPqv/0tN3/zL2c/ysowP/p1/H/t+Nl/888Ov+X0vH/Plyb/+SbdP/B6q7/4jbg/6+S\n5v/b3hv/z2mK/8P09f96xtf/tB00/7nVPP/JnPT/wDGm/5Lugv/q2Mb/Umff/7PP7f/mWjr/\nb6g4/9d46P+Je8X/9e7L/+Scv/8i3sL/sdvY/9Y3dv+gmC3/h2Xo/85W1v/Q9rb/2qWS/yNm\nyf9/hd7/wn8b/2PAXf/vrd7/izzB/9Ttj//zycz/UsLr/yiuvP/vdZL/5uq6/4dD4f/eptn/\nVNgs/9qbav/M1vj/T5LG//CspP+x33X/lhe9/8nF7//lwk//rEiB/4zo0/8/u6P/64+///Lq\nyP9nUen/yX/b/3K+HP+4bmL/rM/u/2yC3//65ND/suSm/90txP/Uwuj/yd1N/7swS/993e3/\nz+jz/+lZXf+YvUb/zZbs/81VqP+x86//5L9+/xcczP+csdb/y1oo/4nUXv/0vPX/UCes/+zp\nZv/lrcH/Nd3Z/5jm3v/hHXT/zcNx/9PI9f+OSZb/qeR7/+rAtP89huH/wsfs/+KgTf88wyz/\n8H7W/49Bzf/e8Z3/zYGJ/yGOrf9txMn/9MLQ/9/kkv9nHdn/7anp/2LnL/+lXzL/bpDo/z2T\nyv/wm5b/5e7Y/79m4P+Rjdn/xZgi/9ZQov+x9eL/jtPC/74kfv/SsFD/s630/6gw0f/J8o//\n8dPQ/12t5f+quuf/4Hkx/1aQQv/icNn/kGbL/+/zvf/kjaP/G8jW/0Wx1P/0paz/wteD/3kf\nuv/rzuT/Zt9b/8SINf+LlO7/NWu0/+uZfv/Q8Ln/2kDp/7Oh6P/i0if/z3qe/9L39P8tqaj/\n6muW/+HhtP9wPNn/3pfe/17TI//ahVv/vtH3/25vt//w3LX/id2I/8cekP/o0fT/u+pc/75H\nSP+Y0e3/tt/n/94/W/+dtCr/rnDt/9VoxP/P98b/2L6l/ypH0/9up+D/uDAV/4fHRv/hnu//\nUkGt/+jXhf/vvtf/R+bL/8Lx5//pSqH/up46/5SI6/+nVr3/ze6l/9yEeP8acbr/pLDf/9l6\nKv+B22n/+Mvz/2wzsf/d63n/4sHI/0rI2v9Vm7f/7J+j/+z01/+2Y+j/44jJ/yPSGv/LomD/\nuLvz/2OQ2P/30sT/ttyf/8wn1P/Cs+j/4Ng7/7UnXf9t7uj/c9TI//fP4v/q4J3/SiLl/+e6\n7f+O5UL/qFVA/4Cw5/8vQ8j/8L+H/87tyv/iVsX/rozM/5azJP/NS1z/peLy/47e4f/SHlP/\nwMNs/9C98v+dMpn/juZp/+q+pf8qYuX/0OPu/+JiXf+UzTP/04/w/0xH2P/136n/24S7/x7C\nkf/U8un/52C2/9SjM/+Wk/P/rVLV/931sv/XkY//I4rE/5Gr5v/cYBv/iM9o//XC8/9fPpn/\n4eRz/+mtwP813uL/NKG7/+yCkf/h58j/m1Pc/9N8wv8zsR//0Ys+/5yo8v90ncv/9dLJ/73l\nmv/FH+D/vLHu/+jPN/+rNGz/dunZ/1jb1P/3u9P/39uU/1Ih0v/fsOL/eNs4/6lNKv9om+v/\nQknB/+3Llf/R9M7/6ljC/7uF3v+Yxh3/vmVq/7Pf8P+w1tr/1jVZ/8zXc//j0vj/vi6u/5bu\nfP/q08H/TG3f/8nf8f/nZFT/hLVG/9aR6v9fUsn/8eGp/+F5s/8XxJ3/eN3K/7wZbf/ArFX/\nsabv/6Q5vP+87Ij/8srC/0ud6v/Ax+T/25BK/0m0Mf/redr/oWnc//L5zP/hpK//KsDb/1ii\nxf/wrK3/wN99/4gZxP/wzOX/WuVX/6qMU/+Ulen/JlOo/+yNYf+95Kn/2jDd/6uX1v/HxCb/\n01qE/7f19P88ppv/53qp/+zntP9kPOX/4Zfp/3PlHP/UhW3/yt33/0RSzf/xzp//i8yE/68i\njv/bxOz/v+FP/8QtPP+B1vD/refr/+U0Y/+bojf/oXLm/8F3vP/R88X/4rWX/yBR2f+NvNz/\nySwg/6LZUP/ksvb/RjzN//HZmP/w2Of/Z+LB/zDOof/xjcv/7+bO/2Fb4/+9j8//gbkl/89V\nT/+r1/P/X3/P//TQuf+j5Yj/1hjN/7+l6P/a4iz/lzhT/2re5P/L5Or/31dn/6TDM//Ah+7/\n1UG1/6v0ov/Xr3//HjG4/6HA5P/eTyj/oMOC//HQ9f9TO6v/6Nt+/+640P9A5tL/m9/c/9Yk\nZv/b1l//0sL4/6curP+d6m//4sS4/0B52v/T1fb/7bhd/0fIQv/vmtb/omPH/+Hyt//iiIv/\nG5rP/2nK2f/4ytP/1d2l/3sr1//puOP/YuBB/7psKf9zjO//S3yn/+eWiv/a7sP/xk3l/4J0\n3v+7mRj/w0+N/6Pv3/9UuJ//7J/M/9nAc/8nGrL/47zw/6PoRP+yRTr/gr7q/yxMsP/spHD/\nwuW3/9xAzv+4muH/ytoi/91ffv/D9Pj/gcrj/8wYJv+uy1j/17Hy/7lLnf+f65j/8+XQ/1xn\n6P+wxeT/3GI4/1+rKf/haOz/fmHS//Xxvv/ToLX/Kcu+/7vs5P/jRJP/opNH/5OC5v/DdtH/\n4/fQ/+isn/8kg+T/hpLS/6kqAD/TFte+ZmYmP9a31z5NArU+ZmZGP7imu77BgiK/ZmYGPzKU\n1z160xi/ZmY2P6uCCD4ZjEE/zczsPhMc9D4AAAAAZmYWPzRCJ780gnO+ZmZWP7JK475wuL6+\nZmYOP4GWND8OdYM+ZmZOP7Qkl71PS9Y+ZmYuP83MrD4xphW/zczcPpivt72CNwK/ZmZeP5fu\ntj57bB4/ZmYePwC6Fz9U5Vy+zcz8Pki8SL+NbN2kZmY+P/7vIb96buS9ZmZSPxG0Rz812gy+\nZmYSP4f4Oj6tbAA/zczkPrJqTCQ5UTm/ZmYyP8EdlT62tbG+ZmYiP9QAcL7S2SQ/ZmZiP8iA\nAz++2Jc+ZmZCP2Ti+b555hS/ZmYCPzio3L77yn6+ZmYqP/G/MT+VvPo9zczUPj+1LiRiYh4/\nZmYKP+Dihz4TrDq/ZmZKP97vRb709Ae/zcz0Pqwt9D4QgBE/ZmY6P502rD7W2ka+ZmZaP9iC\nJ783S+w9ZmYaP/Y5Dr9XF0c9ZmY0P2UcKz+mlJ++zczoPl3pVD7dCJg+ZmYUPyCqLr7Z9iK/\nZmZUP5b4Uj7kNuK+ZmYEP3D2eb1hkTI/ZmZEPwl1Fz/QVCI+ZmZkP77cIb+jrOK+ZmYkP6Qk\ngb59b7i+ZmZMP1uiDj9Av8c+ZmYMP5/Gfb5XDgg/zczYPryrCD+8qwi/ZmYsPwVAYz2vVyK/\nZmYcP6fhUD6Z40I/ZmZcPyD6BT8nizu9ZmY8P27bMb9woD6+zcz4Plw9Cr+vgkG9ZmYIP88i\nND+zEUG+ZmZIPx82jD6YVxY/ZmYoP5IYjr1DBUu/zczQPk0gsD7EiPu+ZmZYP69aSr6QzDw/\nZmYYP8jw1z60Y0k+zczwPnbr+b526/m+ZmY4PxX0EL+RL4e+zczgPjzwRj8lPYs9ZmYwP9oY\nNT0vXwE/ZmZQPx4hPD7vhi+/ZmYQPxStML4Kcb2+ZmZAPyp68j4qevI+ZmYAP7sU8D5FG6i+\nZmYgP3SNOL+GzUU+ZmZgP0LcGb+rcAg+ZmYfPwgZJz/z59S+ZmZfP5Bnqj7E9rk+ZmY/Py6r\nib5ILia/zcz+Pv3k5z1s3re+ZmZPPxl27DzWPik/ZmYPP86ADj9QFpY9zczePiX5J7/14a6+\nZmYvPxo0t7567se+zczuPpjaIz8HmKo+ZmY3P6XnRL4oIBw/ZmZXP0lG9j7CeSC/ZmYXP+LA\n0rxi2Ba/ZmYnP9tZlD5TEzM/zczOPhA63z7p88W9ZmYHP8pILb+rgba9ZmZHPwwS5r73FBG+\nZmY7P4wwMT9/j/e8zcz2PhakBT4wtBY/ZmYbP4qpzD0OUkK/ZmZbPxWp9T46G+G+zczWPmmr\nvL4nNzU/ZmYrPxvP3T41M6o+ZmZLPyEHyb53xh2/ZmYLP2X36b5ah7O+ZmZjP7XANj+mfGY+\nZmYjP17nXr3qo9M+ZmYDP2f2nj6crhi/ZmZDPyXu4r1w5/++ZmYTP8Dtwz7zxRk/ZmZTP8d4\nFD8C/3W+ZmYzPwUHSL/zuws9zczmPnPI9L6654A9ZmZdP91wHj9M9aS+ZmYdP7ztvT4Uhfc+\nzcz6PjcJbb4P8ju/ZmY9P9gLWT6//wK/ZmYNP5ldA71HDDw/ZmZNP9UMrD4Ekpg9ZmYtP5yz\nDb85jLS+zczaPqGAxb7ysQC/ZmZFP7O7KT+SQ9g+ZmYFP9gmTL7VbvY+ZmYlP5P89z6hUAe/\nZmZlPyGTmjx+Rd2+zczqPqClUD6YbyU/ZmY1P1/3Ez9P15u9ZmZVP5spPL/H2ya+ZmYVP6GM\nGL9jItW8ZmYBP6zlOT/dc2q+ZmZBPysxWT5tnNA+ZmZhP5jct70vki6/ZmYhPx4AlD5uUOi+\nZmYxPwDzIL6ufzU/zcziPjKXGD8G0nw+ZmYRP8bhFb9rVwm/ZmZRPyWnvL4CSRy+ZmYZP76d\n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\nZiYFP9RJLb9B9/E7ZiZFP/1pGb9nwnE9ZiYLP0SZMD/Saam+ZiZLP1IWjD7QfcM+ZiYrP0ro\nPr6dpiq/zUzWPj5aZj4NM/6+ZiZbPx4nZL3tYTo/ZiYbPwY2IT+ZRCU+zUz2PkCEKL82jua+\nZiY7Pxlsd76Bo6y+zUzmPm/uDT/bLsI+ZiYzPwIMc76fGgY/ZiZTP9HpBT8C3gi/ZiYTPwLq\nQz3MCyC/ZiZDPzGRVz6tsUA/ZiYDPx8iAj96Ek29ZiYjP854ML+x6TS+ZiZjP7bY+r4siBm9\nZiYvP3UTLT/UnkG+zUzePnwkiD6v6g0/ZiYPPyZBm71pCkW/ZiZPP98Ioj4H3uy+zUz+Po3q\nO76nTTc/ZiY/P1sWrj6BwR0+ZiZfP9rt8b4xtey+ZiYfP0zxFL9S+Ia+ZiZHP/mOST/YunY9\nZiYHPwE2VD3TqQY/zUzOPllMNz55zDK/ZiYnPykHRb5wYs2+ZiYXP6Cf+T50PPQ+ZiZXP1Ec\n9T7PpK++ZiY3PwSJOr9hrVA+zUzuPkXN9r6ouxU+ZqYdP63/ED/Yidm+ZqZdP/We6D6O39k+\nZqY9PxsxtL7sxzG/zUz7Phh6BD5oCg6/ZqZNP3mQtj1uRT0/ZqYNP/MjzT5PMrM8zUzbPo82\nHb++Roa+ZqYtP2Jb8b4zDuK+ZqYFP68SOz+fx58+ZqZFP7ur+r0xYgY/ZqZlP71Xyz6d0Bu/\nZqYlP4/3Yb20ROq+ZqY1P+lVnz4qNB0/zUzrPjdSEj9MizG+ZqYVP5DDQr/fISq9ZqZVPyaP\nEb8wwge+ZqZBP257Pz9rsri9ZqYBPyIhAT5i19Q+ZqYhPwdyFz0eXy2/ZqZhP6S5tj76F8O+\nzUzjPmJHkL6Z7Cg/ZqYxP4sCCD8of7E+ZqZRPxCv8b65FyG/ZqYRP+HSlb4shkO+ZqZZP7HL\nIz9lxBg+ZqYZP73H97yq0w0/zUzzPvT1kz4tPC2/ZqY5PwNeNb7PeBW/ZqYJP9Sq7D66vx0/\nZqZJP8XW3D5u1V++ZqYpP7J+Mb+QNKs9zUzTPh3PIL9/dag8ZqZfPx3sOT/KSpW+ZqYfP++5\nij4NF98+zUz/PiszFr7RkjK/ZqY/P/9ASj75Mb2+ZqYPP+zPwr21kSo/ZqZPPzBaDD+bxDc+\nZqYvPwnaFr9Bx+y+zUzfPjjok76e2u2+ZqY3PwpHEz8SK+c+zUzvPqw8nb66FRM/ZqYXPww3\n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\nwH8zMzM/AADAfwAAwH/NzEw/AAAAAQ=="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<p id="rgl97316-aria" hidden>
</p>
</div>
<p>The program then proceeds by projecting these colors into the sRGB
space.</p>
<div class="figure">
<div id="rgl69344" style="width:288px;height:288px;" class="rglWebGL html-widget " aria-labelledby="rgl69344-aria"></div>
<script type="application/json" data-for="rgl69344">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":1,"objects":{"19":{"id":19,"type":"points","material":{"lit":false},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"21":{"id":21,"type":"text","material":{"lit":false,"margin":0,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["RGB"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"22":{"id":22,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"6","colors":"7","texts":[["R"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"23":{"id":23,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["G"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"24":{"id":24,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"12","colors":"13","texts":[["B"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":"15","centers":"16","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"20":{"id":20,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"17","colors":"18","axes":{"mode":["pretty","pretty","pretty"],"step":[0.2000000029802322,0.2000000029802322,0.2000000029802322],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.029999971389771,1.029999971389771,1.029999971389771]},"draw_front":true,"flags":32769},"1":{"id":1,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,3.777960538864136],"modelMatrix":[[1.002808213233948,0,0,-0.5355870127677917],[0,0.3417933881282806,0.937694787979126,-0.6778346300125122],[0,-0.9390696287155151,0.3412930071353912,-3.461941003799438],[0,0,0,1]],"projMatrix":[[3.732050657272339,0,0,0],[0,3.732050657272339,0,0],[0,0,-3.863703012466431,-13.61910820007324],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1.002808213233948,0.9993370175361633,0.9978739619255066],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[0.0896475538611412,0.9785268306732178,0.08316178619861603,0.9751285910606384,0.08336060494184494,0.976635217666626],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,20,19,21,22,23,24,5],"subscenes":[],"flags":36113}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":288,"height":288,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1000,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":15,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":16,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":17,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":12000,"byteOffset":0},{"buffer":0,"byteLength":4000,"byteOffset":12000},{"buffer":0,"byteLength":12000,"byteOffset":16000},{"buffer":0,"byteLength":12,"byteOffset":28000},{"buffer":0,"byteLength":4,"byteOffset":28012},{"buffer":0,"byteLength":12,"byteOffset":28016},{"buffer":0,"byteLength":12,"byteOffset":28028},{"buffer":0,"byteLength":4,"byteOffset":28040},{"buffer":0,"byteLength":12,"byteOffset":28044},{"buffer":0,"byteLength":12,"byteOffset":28056},{"buffer":0,"byteLength":4,"byteOffset":28068},{"buffer":0,"byteLength":12,"byteOffset":28072},{"buffer":0,"byteLength":12,"byteOffset":28084},{"buffer":0,"byteLength":4,"byteOffset":28096},{"buffer":0,"byteLength":12,"byteOffset":28100},{"buffer":0,"byteLength":4,"byteOffset":28112},{"buffer":0,"byteLength":3,"byteOffset":28116},{"buffer":0,"byteLength":144,"byteOffset":28120},{"buffer":0,"byteLength":4,"byteOffset":28264}],"buffers":[{"byteLength":28268,"bytes":"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\nAj+6v2Y/GHZDPz6r7T4uN1I/rVJkP8Trdz8JIVE/xmNpPyBVLD8HqR8//3USPqSGAz9Nb2Q/\nQoEGP0DIEj+Li1I/4Gu5/+XQpv8tLd//xYni/5TQG//IZGT/ud/y/0x4z//zwan/otCL/7gk\nuP/YzO//4+NY/80uY/+K8fH/tOXv/+g7WP+brzX/snrq/8x4vv/U9s3/5sKd/yND4f9/qtT/\ntTgf/4rSQf/loPP/TDW//+3chv/oy9r/V93H/4re1//JHmb/u7Rt/8W38P+2SMD/ve2a//Tb\n0/9dmOr/tbni/9qZPv83qy3/623L/6Zd2//q98D/35ie/yOo1f9Hvsj/8J+z/9fgb/9aFbv/\n78Dr/3DnSf+wb0D/hp/p/yp8tv/ufHL/1Oi4/7dB3/+qptr/1aor/9Zpqf/I9+v/ZNrB//jF\n4f/e0Z//PCbY/9m84f+V2UX/rUAx/3O06v84Urb/67KD/8fwvf/pRNX/onPb/6G1Gf+9UWj/\noOPt/5rI2//QJi3/tNde/+K/9v+xJYj/be5n/+fSrv82PeD/0t7z/+iGXv92t0//6Jrr/3xb\nyv/y8LP/44On/xnNxf/M7en/4ViX/8m2Mf+fivD/vE7M/8ryqP/JnJD/JWe0/6Cp6v/ljSX/\ngdR2//fS8P95Qqj/0ueC/+28wv9Fw+X/NsbM//CRrf/t79P/kWDi/9uH1/9Pwx//2H9K/6zB\n9f9wo8L/8sG//8Phkf+eH9P/qqfq/+WvLf+eNHb/bObC/6vp2P/jMp3/moA7/3hw5P+zZc//\n4PW//+aUjv8aj9v/lqXP/75jJ/92z1b/87Hv/3I2z//r8ZP/8NTc/2Hb4/82jaf/6HWB/9/t\nr/+ZNub/45nS/zTdIP/Go3b/yM30/zh91f/zrpn/oNd2/6Icsf/Mw+n/39BO/74vbv9/7uL/\nYcC+//Cwx//e3IL/URzF//PM9P+L61b/wmg//5Oz7f8vMaL/6Ltp/7fatv/WO6b/wpba/5jM\nJf/XWlz/uuP2/3nR4P/BGDj/tcZT/8uo8P+tS5//oOmQ//DbyP9Tbub/vdXr/+JeR/94vyn/\n2Xnw/35u2v/58c//36nF/zDZuf+k4tT/3CuO/97Daf/Szfn/mDC3/7rsev/mxMD/Spzc/8XP\n8f/okk7/W7dA/+uM4f+GYrT/5u2p/9p9kv8cqrv/XLLS//W5vf/E1Jr/iCjH/+Or1P893DP/\nqHUn/2Nr7P9Ec7r/66uT/9vyzP/fVuj/mHzj/8i9F//MU4P/rPLu/yzHsf/wgrf/7efF/2tQ\n4//Fg9D/ZrIh/89eRP+gx/L/c4DQ//bizP+m55v/4yC+/9K36//E40D/nUZT/37R5f/a7/D/\n4mmP/8nMP/+4mvH/2FPV/8n2tP/bqo//IlbJ/5XJ5f/eIR3/q8xv/+bF9f80Man/6cRx/+6t\n1/8z6K//jOfL/9sYlP/RsGL/v771/343nP+65W7/6qup/zCi5P/S2/H/5I9f/2LRM//yke//\ngFLR//H0r//SkaT/Jbq+/4O6yP/21Nn/2eal/4ss4P/vvOX/WudE/7B5O/+CkOn/M3nI/++f\njP/c7c7/zlvg/5OC2f+9qB7/1kWJ/6b16v9Bxr//75i5//Xz0f+EW+z/3Ibh/1/MG//FfmL/\ntczx/11k2v/34r//nd6Z/9Mkov/QtuD/rdk+/6kuNf9tx+r/wejt/+RLbf+Zo03/s4jn/8JO\ntP+x7qD/3aJy/xg7uP+kwtv/1j0p/6XXaP/tx/f/OSm3/+7Tcf/ottL/QOC9/7vm3v/cRZL/\ntJwu/4d17P/IZN3/4fnI/+Kpn/8lg9z/d4na/7dnG/9quFr/7aTh/3c8tf/b6of/8MDJ/0nP\n6P8rhK//7G1u/9XltP+mPdz/06bE/y3OK//Trmb/w8P2/12DzP/zybb/puSF/84Z0P/f1fT/\n6edg/7lQdP+d7Ov/RdHE//OixP/Sy4P/RCG1/+vG7v+Q5FH/ylEr/4Sy8f9DTKL/5rp//73s\nuf/kQb3/yJzo/7XkIf/Sc3z/zu33/4fQ1v+8IUn/ytRJ/8ep9P/GOLv/qO6P/+rc0v9fgN7/\nos3r/+Y1KP9xnTD/xWfm/29oxf/y5Lv/4Yy+/x3Qov9szrP/9cXi/+bPlP8mHN//2bDp/6Hi\nOP+ZRkH/drrk/zZj1P/zupf/3/PX/+Zk4P+tk9f/vcYl/9RWef+18vX/ndXl/+AiOP+4ynj/\n48z1/6w2kv+G6Xn/7tS0/ztO6P/L1+b/3HNW/3K8Nv/hhez/YUHR//Ppn//Tf6X/ILOi/8vz\n8v/qVIv/wLw+/62R7f+7YL7/xu+u/92dgf8cWcP/kJLe/86PIP9Y21P/97fk/3gppv/C6mT/\n4ayu/zSo2v9Eo7L/6Yyf/+rwxf+WT+f/4XXS/zjAFv/Jh07/pbTx/2+m1//41M7/xNqs/7Ux\n1f/Dven/38FH/7oseP947tf/MreX/+x8vP/m3cL/Wkzc/9Sm4v+R2y3/3XZr/87n+f9WcML/\n78ep/5Leev+/Gq//2MXz/9zrTf/AOVn/i+Tt/6vW5f/eMz//iKsm/7Vj7f/VXLX/v/W6/9e+\nmf8mMsr/f6fg/8dHGv+Gxlr/7K/x/2pSr//q45b/8c7d/1rm3P+Dyb7/qiJl/8u1Qv+qm/D/\nqS2//7Xvff/qycH/TJXg/7G66//kkDj/TKA8/+Z20v+fatL/7fbG/+iUof8av+L/TdXX//Wu\nxf/Z2or/WSHE/+7V7v+M4WP/y2s6/5Sy8P83ep3/5XBv/9Tqqv+qMOT/lZTg/9SaIf+7eqT/\nwfLi/1nPqv/0tN3/zL2c/ysowP/p1/H/t+Nl/888Ov+X0vH/Plyb/+SbdP/B6q7/4jbg/6+S\n5v/b3hv/z2mK/8P09f96xtf/tB00/7nVPP/JnPT/wDGm/5Lugv/q2Mb/Umff/7PP7f/mWjr/\nb6g4/9d46P+Je8X/9e7L/+Scv/8i3sL/sdvY/9Y3dv+gmC3/h2Xo/85W1v/Q9rb/2qWS/yNm\nyf9/hd7/wn8b/2PAXf/vrd7/izzB/9Ttj//zycz/UsLr/yiuvP/vdZL/5uq6/4dD4f/eptn/\nVNgs/9qbav/M1vj/T5LG//CspP+x33X/lhe9/8nF7//lwk//rEiB/4zo0/8/u6P/64+///Lq\nyP9nUen/yX/b/3K+HP+4bmL/rM/u/2yC3//65ND/suSm/90txP/Uwuj/yd1N/7swS/993e3/\nz+jz/+lZXf+YvUb/zZbs/81VqP+x86//5L9+/xcczP+csdb/y1oo/4nUXv/0vPX/UCes/+zp\nZv/lrcH/Nd3Z/5jm3v/hHXT/zcNx/9PI9f+OSZb/qeR7/+rAtP89huH/wsfs/+KgTf88wyz/\n8H7W/49Bzf/e8Z3/zYGJ/yGOrf9txMn/9MLQ/9/kkv9nHdn/7anp/2LnL/+lXzL/bpDo/z2T\nyv/wm5b/5e7Y/79m4P+Rjdn/xZgi/9ZQov+x9eL/jtPC/74kfv/SsFD/s630/6gw0f/J8o//\n8dPQ/12t5f+quuf/4Hkx/1aQQv/icNn/kGbL/+/zvf/kjaP/G8jW/0Wx1P/0paz/wteD/3kf\nuv/rzuT/Zt9b/8SINf+LlO7/NWu0/+uZfv/Q8Ln/2kDp/7Oh6P/i0if/z3qe/9L39P8tqaj/\n6muW/+HhtP9wPNn/3pfe/17TI//ahVv/vtH3/25vt//w3LX/id2I/8cekP/o0fT/u+pc/75H\nSP+Y0e3/tt/n/94/W/+dtCr/rnDt/9VoxP/P98b/2L6l/ypH0/9up+D/uDAV/4fHRv/hnu//\nUkGt/+jXhf/vvtf/R+bL/8Lx5//pSqH/up46/5SI6/+nVr3/ze6l/9yEeP8acbr/pLDf/9l6\nKv+B22n/+Mvz/2wzsf/d63n/4sHI/0rI2v9Vm7f/7J+j/+z01/+2Y+j/44jJ/yPSGv/LomD/\nuLvz/2OQ2P/30sT/ttyf/8wn1P/Cs+j/4Ng7/7UnXf9t7uj/c9TI//fP4v/q4J3/SiLl/+e6\n7f+O5UL/qFVA/4Cw5/8vQ8j/8L+H/87tyv/iVsX/rozM/5azJP/NS1z/peLy/47e4f/SHlP/\nwMNs/9C98v+dMpn/juZp/+q+pf8qYuX/0OPu/+JiXf+UzTP/04/w/0xH2P/136n/24S7/x7C\nkf/U8un/52C2/9SjM/+Wk/P/rVLV/931sv/XkY//I4rE/5Gr5v/cYBv/iM9o//XC8/9fPpn/\n4eRz/+mtwP813uL/NKG7/+yCkf/h58j/m1Pc/9N8wv8zsR//0Ys+/5yo8v90ncv/9dLJ/73l\nmv/FH+D/vLHu/+jPN/+rNGz/dunZ/1jb1P/3u9P/39uU/1Ih0v/fsOL/eNs4/6lNKv9om+v/\nQknB/+3Llf/R9M7/6ljC/7uF3v+Yxh3/vmVq/7Pf8P+w1tr/1jVZ/8zXc//j0vj/vi6u/5bu\nfP/q08H/TG3f/8nf8f/nZFT/hLVG/9aR6v9fUsn/8eGp/+F5s/8XxJ3/eN3K/7wZbf/ArFX/\nsabv/6Q5vP+87Ij/8srC/0ud6v/Ax+T/25BK/0m0Mf/redr/oWnc//L5zP/hpK//KsDb/1ii\nxf/wrK3/wN99/4gZxP/wzOX/WuVX/6qMU/+Ulen/JlOo/+yNYf+95Kn/2jDd/6uX1v/HxCb/\n01qE/7f19P88ppv/53qp/+zntP9kPOX/4Zfp/3PlHP/UhW3/yt33/0RSzf/xzp//i8yE/68i\njv/bxOz/v+FP/8QtPP+B1vD/refr/+U0Y/+bojf/oXLm/8F3vP/R88X/4rWX/yBR2f+NvNz/\nySwg/6LZUP/ksvb/RjzN//HZmP/w2Of/Z+LB/zDOof/xjcv/7+bO/2Fb4/+9j8//gbkl/89V\nT/+r1/P/X3/P//TQuf+j5Yj/1hjN/7+l6P/a4iz/lzhT/2re5P/L5Or/31dn/6TDM//Ah+7/\n1UG1/6v0ov/Xr3//HjG4/6HA5P/eTyj/oMOC//HQ9f9TO6v/6Nt+/+640P9A5tL/m9/c/9Yk\nZv/b1l//0sL4/6curP+d6m//4sS4/0B52v/T1fb/7bhd/0fIQv/vmtb/omPH/+Hyt//iiIv/\nG5rP/2nK2f/4ytP/1d2l/3sr1//puOP/YuBB/7psKf9zjO//S3yn/+eWiv/a7sP/xk3l/4J0\n3v+7mRj/w0+N/6Pv3/9UuJ//7J/M/9nAc/8nGrL/47zw/6PoRP+yRTr/gr7q/yxMsP/spHD/\nwuW3/9xAzv+4muH/ytoi/91ffv/D9Pj/gcrj/8wYJv+uy1j/17Hy/7lLnf+f65j/8+XQ/1xn\n6P+wxeT/3GI4/1+rKf/haOz/fmHS//Xxvv/ToLX/Kcu+/7vs5P/jRJP/opNH/5OC5v/DdtH/\n4/fQ/+isn/8kg+T/hpLS/1n1YD/ortc+Yus5P3sUZj/D9VA/UrgmPwgQNT4IEDU+y4hfP5NF\nRT/iyAk/6wNjP+eyFD/pS1E/HAfcPWS/SD/SGsg+0hrIPuV5OT+RCmA/51JzP7simT5y6fA+\nbztQP2micz8Q/UE/ZCopPwrXIj97FFE/UrgLP4XrOD8fhQ8+hes4P3mdWD+eC00/LsFvP5Ak\nZD+QJGQ/elCxPnQfTj9htTo+w6bHPif2Cj+m1nE/ptZxPyMcNT8+7WU/qrBvP4o3aT8KVW4+\nSAuxPoAdGz8NeS8/AE9VPmZmMj+Pc/Q+BZNqPzzPTD8h++8+Sqw+P5LgVD8lr3Y/px1OPyfw\nZj9mZkI/pdwdP1gjDD5ipYU+98NhP4ea/z5mZio/if9UP7xqNT8MjmE+iRD7PWZmCj9lKFM/\nz0iDPukgZj+iziA/K/5zP6iQmD4r5VQ+gpM/PwUKbj9701w/x8IGP98AaT/uy0s/ZmZaP3PJ\nrT4T6F0/hGdHPwM9Cj/Kj14/5IhXP7g+Sj+kcPQ9XC/MPq5nOz935zQ/PcraPnUIRj+Dqjc/\nSSJxP82cNj89SpA+rqdAP9pxPT+zIW4/GqsaPxROdT+P8ls/uH5TP/dkuz6/nRg/URprP2y1\nNT+WfTk/YRdjPygHWz8xgRk/khZ3Ps21XT6K9ys/C1UzPsGEaz8XkNo+lPVLP5T3Jj+l/rk+\n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\nwH8AAMB/mpkZPwAAwH8AAMB/zcxMPwAAAAE="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<p id="rgl69344-aria" hidden>
</p>
</div>
<p>It then continues projecting the colors, first into the XYZ space,
then CIELab (not shown here), and then finally the DIN99d space.</p>
<div class="figure">
<div id="rgl9077" style="width:288px;height:288px;" class="rglWebGL html-widget " aria-labelledby="rgl9077-aria"></div>
<script type="application/json" data-for="rgl9077">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":1,"objects":{"31":{"id":31,"type":"points","material":{"lit":false},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"33":{"id":33,"type":"text","material":{"lit":false,"margin":0,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["DIN99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"34":{"id":34,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"6","colors":"7","texts":[["L99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"35":{"id":35,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["a99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"36":{"id":36,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"12","colors":"13","texts":[["b99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":"15","centers":"16","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"32":{"id":32,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"17","colors":"18","axes":{"mode":["pretty","pretty","pretty"],"step":[10,20,20],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.029999971389771,1.029999971389771,1.029999971389771]},"draw_front":true,"flags":32769},"1":{"id":1,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,325.2228393554688],"modelMatrix":[[1.115169644355774,0,0,-69.56121826171875],[0,0.3409429788589478,0.8615754246711731,-0.06915782392024994],[0,-0.9367331266403198,0.3135878145694733,-322.4158325195312],[0,0,0,1]],"projMatrix":[[3.732050657272339,0,0,0],[0,3.732050657272339,0,0],[0,0,-3.863702774047852,-1172.390625],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1.115169644355774,0.9968505501747131,0.9168694019317627],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[27.97290229797363,96.78160095214844,-35.81810760498047,41.15769577026367,-42.82153701782227,40.86908721923828],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,32,31,33,34,35,36,5],"subscenes":[],"flags":36113}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":288,"height":288,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1000,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":15,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":16,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":17,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":12000,"byteOffset":0},{"buffer":0,"byteLength":4000,"byteOffset":12000},{"buffer":0,"byteLength":12000,"byteOffset":16000},{"buffer":0,"byteLength":12,"byteOffset":28000},{"buffer":0,"byteLength":4,"byteOffset":28012},{"buffer":0,"byteLength":12,"byteOffset":28016},{"buffer":0,"byteLength":12,"byteOffset":28028},{"buffer":0,"byteLength":4,"byteOffset":28040},{"buffer":0,"byteLength":12,"byteOffset":28044},{"buffer":0,"byteLength":12,"byteOffset":28056},{"buffer":0,"byteLength":4,"byteOffset":28068},{"buffer":0,"byteLength":12,"byteOffset":28072},{"buffer":0,"byteLength":12,"byteOffset":28084},{"buffer":0,"byteLength":4,"byteOffset":28096},{"buffer":0,"byteLength":12,"byteOffset":28100},{"buffer":0,"byteLength":4,"byteOffset":28112},{"buffer":0,"byteLength":3,"byteOffset":28116},{"buffer":0,"byteLength":192,"byteOffset":28120},{"buffer":0,"byteLength":4,"byteOffset":28312}],"buffers":[{"byteLength":28316,"bytes":"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\nCEFe8vrBBxmBQgn2v0FSGrnBJDi/QgHbQcGr3HZBGW+cQsi1oUExUTJBi/9nQlBRSsE6cwLC\nqOuCQiU2z7/mz83B4Gu5/+XQpv8tLd//xYni/5TQG//IZGT/ud/y/0x4z//zwan/otCL/7gk\nuP/YzO//4+NY/80uY/+K8fH/tOXv/+g7WP+brzX/snrq/8x4vv/U9s3/5sKd/yND4f9/qtT/\ntTgf/4rSQf/loPP/TDW//+3chv/oy9r/V93H/4re1//JHmb/u7Rt/8W38P+2SMD/ve2a//Tb\n0/9dmOr/tbni/9qZPv83qy3/623L/6Zd2//q98D/35ie/yOo1f9Hvsj/8J+z/9fgb/9aFbv/\n78Dr/3DnSf+wb0D/hp/p/yp8tv/ufHL/1Oi4/7dB3/+qptr/1aor/9Zpqf/I9+v/ZNrB//jF\n4f/e0Z//PCbY/9m84f+V2UX/rUAx/3O06v84Urb/67KD/8fwvf/pRNX/onPb/6G1Gf+9UWj/\noOPt/5rI2//QJi3/tNde/+K/9v+xJYj/be5n/+fSrv82PeD/0t7z/+iGXv92t0//6Jrr/3xb\nyv/y8LP/44On/xnNxf/M7en/4ViX/8m2Mf+fivD/vE7M/8ryqP/JnJD/JWe0/6Cp6v/ljSX/\ngdR2//fS8P95Qqj/0ueC/+28wv9Fw+X/NsbM//CRrf/t79P/kWDi/9uH1/9Pwx//2H9K/6zB\n9f9wo8L/8sG//8Phkf+eH9P/qqfq/+WvLf+eNHb/bObC/6vp2P/jMp3/moA7/3hw5P+zZc//\n4PW//+aUjv8aj9v/lqXP/75jJ/92z1b/87Hv/3I2z//r8ZP/8NTc/2Hb4/82jaf/6HWB/9/t\nr/+ZNub/45nS/zTdIP/Go3b/yM30/zh91f/zrpn/oNd2/6Icsf/Mw+n/39BO/74vbv9/7uL/\nYcC+//Cwx//e3IL/URzF//PM9P+L61b/wmg//5Oz7f8vMaL/6Ltp/7fatv/WO6b/wpba/5jM\nJf/XWlz/uuP2/3nR4P/BGDj/tcZT/8uo8P+tS5//oOmQ//DbyP9Tbub/vdXr/+JeR/94vyn/\n2Xnw/35u2v/58c//36nF/zDZuf+k4tT/3CuO/97Daf/Szfn/mDC3/7rsev/mxMD/Spzc/8XP\n8f/okk7/W7dA/+uM4f+GYrT/5u2p/9p9kv8cqrv/XLLS//W5vf/E1Jr/iCjH/+Or1P893DP/\nqHUn/2Nr7P9Ec7r/66uT/9vyzP/fVuj/mHzj/8i9F//MU4P/rPLu/yzHsf/wgrf/7efF/2tQ\n4//Fg9D/ZrIh/89eRP+gx/L/c4DQ//bizP+m55v/4yC+/9K36//E40D/nUZT/37R5f/a7/D/\n4mmP/8nMP/+4mvH/2FPV/8n2tP/bqo//IlbJ/5XJ5f/eIR3/q8xv/+bF9f80Man/6cRx/+6t\n1/8z6K//jOfL/9sYlP/RsGL/v771/343nP+65W7/6qup/zCi5P/S2/H/5I9f/2LRM//yke//\ngFLR//H0r//SkaT/Jbq+/4O6yP/21Nn/2eal/4ss4P/vvOX/WudE/7B5O/+CkOn/M3nI/++f\njP/c7c7/zlvg/5OC2f+9qB7/1kWJ/6b16v9Bxr//75i5//Xz0f+EW+z/3Ibh/1/MG//FfmL/\ntczx/11k2v/34r//nd6Z/9Mkov/QtuD/rdk+/6kuNf9tx+r/wejt/+RLbf+Zo03/s4jn/8JO\ntP+x7qD/3aJy/xg7uP+kwtv/1j0p/6XXaP/tx/f/OSm3/+7Tcf/ottL/QOC9/7vm3v/cRZL/\ntJwu/4d17P/IZN3/4fnI/+Kpn/8lg9z/d4na/7dnG/9quFr/7aTh/3c8tf/b6of/8MDJ/0nP\n6P8rhK//7G1u/9XltP+mPdz/06bE/y3OK//Trmb/w8P2/12DzP/zybb/puSF/84Z0P/f1fT/\n6edg/7lQdP+d7Ov/RdHE//OixP/Sy4P/RCG1/+vG7v+Q5FH/ylEr/4Sy8f9DTKL/5rp//73s\nuf/kQb3/yJzo/7XkIf/Sc3z/zu33/4fQ1v+8IUn/ytRJ/8ep9P/GOLv/qO6P/+rc0v9fgN7/\nos3r/+Y1KP9xnTD/xWfm/29oxf/y5Lv/4Yy+/x3Qov9szrP/9cXi/+bPlP8mHN//2bDp/6Hi\nOP+ZRkH/drrk/zZj1P/zupf/3/PX/+Zk4P+tk9f/vcYl/9RWef+18vX/ndXl/+AiOP+4ynj/\n48z1/6w2kv+G6Xn/7tS0/ztO6P/L1+b/3HNW/3K8Nv/hhez/YUHR//Ppn//Tf6X/ILOi/8vz\n8v/qVIv/wLw+/62R7f+7YL7/xu+u/92dgf8cWcP/kJLe/86PIP9Y21P/97fk/3gppv/C6mT/\n4ayu/zSo2v9Eo7L/6Yyf/+rwxf+WT+f/4XXS/zjAFv/Jh07/pbTx/2+m1//41M7/xNqs/7Ux\n1f/Dven/38FH/7oseP947tf/MreX/+x8vP/m3cL/Wkzc/9Sm4v+R2y3/3XZr/87n+f9WcML/\n78ep/5Leev+/Gq//2MXz/9zrTf/AOVn/i+Tt/6vW5f/eMz//iKsm/7Vj7f/VXLX/v/W6/9e+\nmf8mMsr/f6fg/8dHGv+Gxlr/7K/x/2pSr//q45b/8c7d/1rm3P+Dyb7/qiJl/8u1Qv+qm/D/\nqS2//7Xvff/qycH/TJXg/7G66//kkDj/TKA8/+Z20v+fatL/7fbG/+iUof8av+L/TdXX//Wu\nxf/Z2or/WSHE/+7V7v+M4WP/y2s6/5Sy8P83ep3/5XBv/9Tqqv+qMOT/lZTg/9SaIf+7eqT/\nwfLi/1nPqv/0tN3/zL2c/ysowP/p1/H/t+Nl/888Ov+X0vH/Plyb/+SbdP/B6q7/4jbg/6+S\n5v/b3hv/z2mK/8P09f96xtf/tB00/7nVPP/JnPT/wDGm/5Lugv/q2Mb/Umff/7PP7f/mWjr/\nb6g4/9d46P+Je8X/9e7L/+Scv/8i3sL/sdvY/9Y3dv+gmC3/h2Xo/85W1v/Q9rb/2qWS/yNm\nyf9/hd7/wn8b/2PAXf/vrd7/izzB/9Ttj//zycz/UsLr/yiuvP/vdZL/5uq6/4dD4f/eptn/\nVNgs/9qbav/M1vj/T5LG//CspP+x33X/lhe9/8nF7//lwk//rEiB/4zo0/8/u6P/64+///Lq\nyP9nUen/yX/b/3K+HP+4bmL/rM/u/2yC3//65ND/suSm/90txP/Uwuj/yd1N/7swS/993e3/\nz+jz/+lZXf+YvUb/zZbs/81VqP+x86//5L9+/xcczP+csdb/y1oo/4nUXv/0vPX/UCes/+zp\nZv/lrcH/Nd3Z/5jm3v/hHXT/zcNx/9PI9f+OSZb/qeR7/+rAtP89huH/wsfs/+KgTf88wyz/\n8H7W/49Bzf/e8Z3/zYGJ/yGOrf9txMn/9MLQ/9/kkv9nHdn/7anp/2LnL/+lXzL/bpDo/z2T\nyv/wm5b/5e7Y/79m4P+Rjdn/xZgi/9ZQov+x9eL/jtPC/74kfv/SsFD/s630/6gw0f/J8o//\n8dPQ/12t5f+quuf/4Hkx/1aQQv/icNn/kGbL/+/zvf/kjaP/G8jW/0Wx1P/0paz/wteD/3kf\nuv/rzuT/Zt9b/8SINf+LlO7/NWu0/+uZfv/Q8Ln/2kDp/7Oh6P/i0if/z3qe/9L39P8tqaj/\n6muW/+HhtP9wPNn/3pfe/17TI//ahVv/vtH3/25vt//w3LX/id2I/8cekP/o0fT/u+pc/75H\nSP+Y0e3/tt/n/94/W/+dtCr/rnDt/9VoxP/P98b/2L6l/ypH0/9up+D/uDAV/4fHRv/hnu//\nUkGt/+jXhf/vvtf/R+bL/8Lx5//pSqH/up46/5SI6/+nVr3/ze6l/9yEeP8acbr/pLDf/9l6\nKv+B22n/+Mvz/2wzsf/d63n/4sHI/0rI2v9Vm7f/7J+j/+z01/+2Y+j/44jJ/yPSGv/LomD/\nuLvz/2OQ2P/30sT/ttyf/8wn1P/Cs+j/4Ng7/7UnXf9t7uj/c9TI//fP4v/q4J3/SiLl/+e6\n7f+O5UL/qFVA/4Cw5/8vQ8j/8L+H/87tyv/iVsX/rozM/5azJP/NS1z/peLy/47e4f/SHlP/\nwMNs/9C98v+dMpn/juZp/+q+pf8qYuX/0OPu/+JiXf+UzTP/04/w/0xH2P/136n/24S7/x7C\nkf/U8un/52C2/9SjM/+Wk/P/rVLV/931sv/XkY//I4rE/5Gr5v/cYBv/iM9o//XC8/9fPpn/\n4eRz/+mtwP813uL/NKG7/+yCkf/h58j/m1Pc/9N8wv8zsR//0Ys+/5yo8v90ncv/9dLJ/73l\nmv/FH+D/vLHu/+jPN/+rNGz/dunZ/1jb1P/3u9P/39uU/1Ih0v/fsOL/eNs4/6lNKv9om+v/\nQknB/+3Llf/R9M7/6ljC/7uF3v+Yxh3/vmVq/7Pf8P+w1tr/1jVZ/8zXc//j0vj/vi6u/5bu\nfP/q08H/TG3f/8nf8f/nZFT/hLVG/9aR6v9fUsn/8eGp/+F5s/8XxJ3/eN3K/7wZbf/ArFX/\nsabv/6Q5vP+87Ij/8srC/0ud6v/Ax+T/25BK/0m0Mf/redr/oWnc//L5zP/hpK//KsDb/1ii\nxf/wrK3/wN99/4gZxP/wzOX/WuVX/6qMU/+Ulen/JlOo/+yNYf+95Kn/2jDd/6uX1v/HxCb/\n01qE/7f19P88ppv/53qp/+zntP9kPOX/4Zfp/3PlHP/UhW3/yt33/0RSzf/xzp//i8yE/68i\njv/bxOz/v+FP/8QtPP+B1vD/refr/+U0Y/+bojf/oXLm/8F3vP/R88X/4rWX/yBR2f+NvNz/\nySwg/6LZUP/ksvb/RjzN//HZmP/w2Of/Z+LB/zDOof/xjcv/7+bO/2Fb4/+9j8//gbkl/89V\nT/+r1/P/X3/P//TQuf+j5Yj/1hjN/7+l6P/a4iz/lzhT/2re5P/L5Or/31dn/6TDM//Ah+7/\n1UG1/6v0ov/Xr3//HjG4/6HA5P/eTyj/oMOC//HQ9f9TO6v/6Nt+/+640P9A5tL/m9/c/9Yk\nZv/b1l//0sL4/6curP+d6m//4sS4/0B52v/T1fb/7bhd/0fIQv/vmtb/omPH/+Hyt//iiIv/\nG5rP/2nK2f/4ytP/1d2l/3sr1//puOP/YuBB/7psKf9zjO//S3yn/+eWiv/a7sP/xk3l/4J0\n3v+7mRj/w0+N/6Pv3/9UuJ//7J/M/9nAc/8nGrL/47zw/6PoRP+yRTr/gr7q/yxMsP/spHD/\nwuW3/9xAzv+4muH/ytoi/91ffv/D9Pj/gcrj/8wYJv+uy1j/17Hy/7lLnf+f65j/8+XQ/1xn\n6P+wxeT/3GI4/1+rKf/haOz/fmHS//Xxvv/ToLX/Kcu+/7vs5P/jRJP/opNH/5OC5v/DdtH/\n4/fQ/+isn/8kg+T/hpLS/2dYgkLNkAJC5ClbwRdgrEK7/GhA+S2iQffzE0LDIwpByv8nwpKR\nikJB5Z1B4NjGwVJdn0Jcp5XBRTQUQl0yaEKq4PFB0A8iQTLZsEIidHbB5IIzwQtWXELnSdPA\nE4z7wZIKqELWTndBF5BzQSitokIlhJbBQwyvQf1+RUKuUgZCBiHCwSvfq0LIJZNALAB3wZgV\ns0IQnbTAcV8TQpLiSkLsJxpC4NINQIgqtUK0/eXBbEmVwFf3skLdJ5jB83XswE9UY0IiYBxC\nPLAhQR0hjkKG5ivBLqQHQmgPgUK1/pFBJjTvwUgsgkIZF9dBCNOEwYDAvEIBx4PBSTJmQRao\npUJN3x9BmkWYQZA/JEIYi3JAOFYkwoRkjkIgI1DB4+WfwTOmOEKwx/xBVqaoQeuxn0I6H63B\n4lEFQv2Tm0K1ULBBbCWwwam1FEKy0zNBF8wUwtMEskKZZHw8vNDvQVymrEJeFDxBtBCNwBbN\npUJU2gLC6PUJQIE5qkIIltXBlQ7cv3hzQkLJRR1C66KPvhjFlkKEbSnAlKjZQW23n0Jp9sxA\n9fCwwdYAV0JGjOxBQRHFwYl5tELW0ZbBmI/EQYo4tUIofQdBReDuQMqeg0IvQS/B447uwZ1Z\nnUJBJ2O/20GYwYCCjkJBf2dBq7n/QW/HgkLwWt/BghrmQUflhkLnCgVCcMSFwVELY0KsrK9B\n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\nAACgQQAAwH8AAMB/AAAgQgAAAAE="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<p id="rgl9077-aria" hidden>
</p>
</div>
<p>The DIN99d color space <span class="citation">(Cui et al.
2002)</span> is a euclidean, perceptually uniform color space. This
means that the difference between two colors is equal to the euclidean
distance between them. We take advantage of this by computing a distance
matrix on all the colors in the subset, finding their pairwise color
differences. We then apply a power transformation <span class="citation">(Huang et al. 2015)</span> to fine tune these
differences.</p>
<p>To select the <code>n</code> colors that the user wanted, we proceed
greedily: first, we find the two most distant points, then we find the
third point that maximizes the minimum distance to the previously
selected points. This is repeated until <code>n</code> points are
selected. These points are then returned to the user; below is an
example using <code>n = 5</code>.</p>
<div class="figure">
<div id="rgl10483" style="width:288px;height:288px;" class="rglWebGL html-widget " aria-labelledby="rgl10483-aria"></div>
<script type="application/json" data-for="rgl10483">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":1,"objects":{"43":{"id":43,"type":"points","material":{"alpha":[0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248,0.09803921729326248],"lit":false,"isTransparent":true},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34848},"45":{"id":45,"type":"text","material":{"lit":false,"margin":0,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["DIN99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"46":{"id":46,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"6","colors":"7","texts":[["L99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"47":{"id":47,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["a99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"48":{"id":48,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"12","colors":"13","texts":[["b99d"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"49":{"id":49,"type":"points","material":{"lit":false,"size":5},"vertices":"15","colors":"16","centers":"17","ignoreExtent":false,"flags":34816},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":"18","centers":"19","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"44":{"id":44,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"20","colors":"21","axes":{"mode":["pretty","pretty","pretty"],"step":[10,20,20],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.029999971389771,1.029999971389771,1.029999971389771]},"draw_front":true,"flags":32769},"1":{"id":1,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,325.3004455566406],"modelMatrix":[[1.115169644355774,0,0,-69.56121826171875],[0,0.3409429788589478,0.8615754246711731,-0.09495473653078079],[0,-0.9367331266403198,0.3135878145694733,-322.5028076171875],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863703727722168,-1172.670654296875],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1.115169644355774,0.9968505501747131,0.9168694019317627],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[27.97290229797363,96.78160095214844,-35.81810760498047,41.15769577026367,-42.82153701782227,40.92897415161133],"windowRect":[0,0,256,256],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":"NA","activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,44,43,45,46,47,48,49,5],"subscenes":[],"flags":36145}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":288,"height":288,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1000,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":1000,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":15,"componentType":5126,"count":5,"type":"VEC3"},{"bufferView":16,"componentType":5121,"count":5,"type":"VEC4","normalized":true},{"bufferView":17,"componentType":5126,"count":5,"type":"VEC3"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":19,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":20,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":21,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":12000,"byteOffset":0},{"buffer":0,"byteLength":4000,"byteOffset":12000},{"buffer":0,"byteLength":12000,"byteOffset":16000},{"buffer":0,"byteLength":12,"byteOffset":28000},{"buffer":0,"byteLength":4,"byteOffset":28012},{"buffer":0,"byteLength":12,"byteOffset":28016},{"buffer":0,"byteLength":12,"byteOffset":28028},{"buffer":0,"byteLength":4,"byteOffset":28040},{"buffer":0,"byteLength":12,"byteOffset":28044},{"buffer":0,"byteLength":12,"byteOffset":28056},{"buffer":0,"byteLength":4,"byteOffset":28068},{"buffer":0,"byteLength":12,"byteOffset":28072},{"buffer":0,"byteLength":12,"byteOffset":28084},{"buffer":0,"byteLength":4,"byteOffset":28096},{"buffer":0,"byteLength":12,"byteOffset":28100},{"buffer":0,"byteLength":60,"byteOffset":28112},{"buffer":0,"byteLength":20,"byteOffset":28172},{"buffer":0,"byteLength":60,"byteOffset":28192},{"buffer":0,"byteLength":4,"byteOffset":28252},{"buffer":0,"byteLength":3,"byteOffset":28256},{"buffer":0,"byteLength":192,"byteOffset":28260},{"buffer":0,"byteLength":4,"byteOffset":28452}],"buffers":[{"byteLength":28456,"bytes":"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"}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<p id="rgl10483-aria" hidden>
</p>
</div>
<div id="color-specifications" class="section level3">
<h3>Color specifications</h3>
<p>At the time of writing, qualpalr works only in the sRGB color space
with the <em>CIE Standard Illuminant D65</em> reference white.</p>
</div>
</div>
<div id="thanks" class="section level2">
<h2>Thanks</h2>
<p><a href="http://www.brucelindbloom.com/">Bruce Lindblooms
webpage</a> has been instrumental in making qualpalr. Thanks also to <a href="https://medialab.github.io/iwanthue/">i want hue</a>, which
inspired me to make qualpalr.</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-cui_uniform_2002" class="csl-entry">
Cui, G., M. R. Luo, B. Rigg, G. Roesler, and K. Witt. 2002.
<span>Uniform Colour Spaces Based on the <span>DIN99</span>
Colour-Difference Formula.</span> <em>Color Research &amp;
Application</em> 27 (4): 28290. <a href="https://doi.org/10.1002/col.10066">https://doi.org/10.1002/col.10066</a>.
</div>
<div id="ref-huang_power_2015" class="csl-entry">
Huang, Min, Guihua Cui, Manuel Melgosa, Manuel Snchez-Maran, Changjun
Li, M. Ronnier Luo, and Haoxue Liu. 2015. <span>Power Functions
Improving the Performance of Color-Difference Formulas.</span>
<em>Optics Express</em> 23 (1): 597. <a href="https://doi.org/10.1364/OE.23.000597">https://doi.org/10.1364/OE.23.000597</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
